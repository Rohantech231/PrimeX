"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@huggingface";
exports.ids = ["vendor-chunks/@huggingface"];
exports.modules = {

/***/ "(ssr)/./node_modules/@huggingface/inference/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@huggingface/inference/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HfInference: () => (/* binding */ HfInference),\n/* harmony export */   HfInferenceEndpoint: () => (/* binding */ HfInferenceEndpoint),\n/* harmony export */   InferenceOutputError: () => (/* binding */ InferenceOutputError),\n/* harmony export */   audioClassification: () => (/* binding */ audioClassification),\n/* harmony export */   audioToAudio: () => (/* binding */ audioToAudio),\n/* harmony export */   automaticSpeechRecognition: () => (/* binding */ automaticSpeechRecognition),\n/* harmony export */   chatCompletion: () => (/* binding */ chatCompletion),\n/* harmony export */   chatCompletionStream: () => (/* binding */ chatCompletionStream),\n/* harmony export */   documentQuestionAnswering: () => (/* binding */ documentQuestionAnswering),\n/* harmony export */   featureExtraction: () => (/* binding */ featureExtraction),\n/* harmony export */   fillMask: () => (/* binding */ fillMask),\n/* harmony export */   imageClassification: () => (/* binding */ imageClassification),\n/* harmony export */   imageSegmentation: () => (/* binding */ imageSegmentation),\n/* harmony export */   imageToImage: () => (/* binding */ imageToImage),\n/* harmony export */   imageToText: () => (/* binding */ imageToText),\n/* harmony export */   objectDetection: () => (/* binding */ objectDetection),\n/* harmony export */   questionAnswering: () => (/* binding */ questionAnswering),\n/* harmony export */   request: () => (/* binding */ request),\n/* harmony export */   sentenceSimilarity: () => (/* binding */ sentenceSimilarity),\n/* harmony export */   streamingRequest: () => (/* binding */ streamingRequest),\n/* harmony export */   summarization: () => (/* binding */ summarization),\n/* harmony export */   tableQuestionAnswering: () => (/* binding */ tableQuestionAnswering),\n/* harmony export */   tabularClassification: () => (/* binding */ tabularClassification),\n/* harmony export */   tabularRegression: () => (/* binding */ tabularRegression),\n/* harmony export */   textClassification: () => (/* binding */ textClassification),\n/* harmony export */   textGeneration: () => (/* binding */ textGeneration),\n/* harmony export */   textGenerationStream: () => (/* binding */ textGenerationStream),\n/* harmony export */   textToImage: () => (/* binding */ textToImage),\n/* harmony export */   textToSpeech: () => (/* binding */ textToSpeech),\n/* harmony export */   tokenClassification: () => (/* binding */ tokenClassification),\n/* harmony export */   translation: () => (/* binding */ translation),\n/* harmony export */   visualQuestionAnswering: () => (/* binding */ visualQuestionAnswering),\n/* harmony export */   zeroShotClassification: () => (/* binding */ zeroShotClassification),\n/* harmony export */   zeroShotImageClassification: () => (/* binding */ zeroShotImageClassification)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/tasks/index.ts\nvar tasks_exports = {};\n__export(tasks_exports, {\n  audioClassification: () => audioClassification,\n  audioToAudio: () => audioToAudio,\n  automaticSpeechRecognition: () => automaticSpeechRecognition,\n  chatCompletion: () => chatCompletion,\n  chatCompletionStream: () => chatCompletionStream,\n  documentQuestionAnswering: () => documentQuestionAnswering,\n  featureExtraction: () => featureExtraction,\n  fillMask: () => fillMask,\n  imageClassification: () => imageClassification,\n  imageSegmentation: () => imageSegmentation,\n  imageToImage: () => imageToImage,\n  imageToText: () => imageToText,\n  objectDetection: () => objectDetection,\n  questionAnswering: () => questionAnswering,\n  request: () => request,\n  sentenceSimilarity: () => sentenceSimilarity,\n  streamingRequest: () => streamingRequest,\n  summarization: () => summarization,\n  tableQuestionAnswering: () => tableQuestionAnswering,\n  tabularClassification: () => tabularClassification,\n  tabularRegression: () => tabularRegression,\n  textClassification: () => textClassification,\n  textGeneration: () => textGeneration,\n  textGenerationStream: () => textGenerationStream,\n  textToImage: () => textToImage,\n  textToSpeech: () => textToSpeech,\n  tokenClassification: () => tokenClassification,\n  translation: () => translation,\n  visualQuestionAnswering: () => visualQuestionAnswering,\n  zeroShotClassification: () => zeroShotClassification,\n  zeroShotImageClassification: () => zeroShotImageClassification\n});\n\n// src/utils/pick.ts\nfunction pick(o, props) {\n  return Object.assign(\n    {},\n    ...props.map((prop) => {\n      if (o[prop] !== void 0) {\n        return { [prop]: o[prop] };\n      }\n    })\n  );\n}\n\n// src/utils/typedInclude.ts\nfunction typedInclude(arr, v) {\n  return arr.includes(v);\n}\n\n// src/utils/omit.ts\nfunction omit(o, props) {\n  const propsArr = Array.isArray(props) ? props : [props];\n  const letsKeep = Object.keys(o).filter((prop) => !typedInclude(propsArr, prop));\n  return pick(o, letsKeep);\n}\n\n// src/lib/isUrl.ts\nfunction isUrl(modelOrUrl) {\n  return /^http(s?):/.test(modelOrUrl) || modelOrUrl.startsWith(\"/\");\n}\n\n// src/lib/getDefaultTask.ts\nvar taskCache = /* @__PURE__ */ new Map();\nvar CACHE_DURATION = 10 * 60 * 1e3;\nvar MAX_CACHE_ITEMS = 1e3;\nvar HF_HUB_URL = \"https://huggingface.co\";\nasync function getDefaultTask(model, accessToken, options) {\n  if (isUrl(model)) {\n    return null;\n  }\n  const key = `${model}:${accessToken}`;\n  let cachedTask = taskCache.get(key);\n  if (cachedTask && cachedTask.date < new Date(Date.now() - CACHE_DURATION)) {\n    taskCache.delete(key);\n    cachedTask = void 0;\n  }\n  if (cachedTask === void 0) {\n    const modelTask = await (options?.fetch ?? fetch)(`${HF_HUB_URL}/api/models/${model}?expand[]=pipeline_tag`, {\n      headers: accessToken ? { Authorization: `Bearer ${accessToken}` } : {}\n    }).then((resp) => resp.json()).then((json) => json.pipeline_tag).catch(() => null);\n    if (!modelTask) {\n      return null;\n    }\n    cachedTask = { task: modelTask, date: /* @__PURE__ */ new Date() };\n    taskCache.set(key, { task: modelTask, date: /* @__PURE__ */ new Date() });\n    if (taskCache.size > MAX_CACHE_ITEMS) {\n      taskCache.delete(taskCache.keys().next().value);\n    }\n  }\n  return cachedTask.task;\n}\n\n// src/lib/makeRequestOptions.ts\nvar HF_INFERENCE_API_BASE_URL = \"https://api-inference.huggingface.co\";\nvar tasks = null;\nasync function makeRequestOptions(args, options) {\n  const { accessToken, endpointUrl, ...otherArgs } = args;\n  let { model } = args;\n  const {\n    forceTask: task,\n    includeCredentials,\n    taskHint,\n    wait_for_model,\n    use_cache,\n    dont_load_model,\n    chatCompletion: chatCompletion2\n  } = options ?? {};\n  const headers = {};\n  if (accessToken) {\n    headers[\"Authorization\"] = `Bearer ${accessToken}`;\n  }\n  if (!model && !tasks && taskHint) {\n    const res = await fetch(`${HF_HUB_URL}/api/tasks`);\n    if (res.ok) {\n      tasks = await res.json();\n    }\n  }\n  if (!model && tasks && taskHint) {\n    const taskInfo = tasks[taskHint];\n    if (taskInfo) {\n      model = taskInfo.models[0].id;\n    }\n  }\n  if (!model) {\n    throw new Error(\"No model provided, and no default model found for this task\");\n  }\n  const binary = \"data\" in args && !!args.data;\n  if (!binary) {\n    headers[\"Content-Type\"] = \"application/json\";\n  }\n  if (wait_for_model) {\n    headers[\"X-Wait-For-Model\"] = \"true\";\n  }\n  if (use_cache === false) {\n    headers[\"X-Use-Cache\"] = \"false\";\n  }\n  if (dont_load_model) {\n    headers[\"X-Load-Model\"] = \"0\";\n  }\n  let url = (() => {\n    if (endpointUrl && isUrl(model)) {\n      throw new TypeError(\"Both model and endpointUrl cannot be URLs\");\n    }\n    if (isUrl(model)) {\n      console.warn(\"Using a model URL is deprecated, please use the `endpointUrl` parameter instead\");\n      return model;\n    }\n    if (endpointUrl) {\n      return endpointUrl;\n    }\n    if (task) {\n      return `${HF_INFERENCE_API_BASE_URL}/pipeline/${task}/${model}`;\n    }\n    return `${HF_INFERENCE_API_BASE_URL}/models/${model}`;\n  })();\n  if (chatCompletion2 && !url.endsWith(\"/chat/completions\")) {\n    url += \"/v1/chat/completions\";\n  }\n  let credentials;\n  if (typeof includeCredentials === \"string\") {\n    credentials = includeCredentials;\n  } else if (includeCredentials === true) {\n    credentials = \"include\";\n  }\n  const info = {\n    headers,\n    method: \"POST\",\n    body: binary ? args.data : JSON.stringify({\n      ...otherArgs.model && isUrl(otherArgs.model) ? omit(otherArgs, \"model\") : otherArgs\n    }),\n    ...credentials && { credentials },\n    signal: options?.signal\n  };\n  return { url, info };\n}\n\n// src/tasks/custom/request.ts\nasync function request(args, options) {\n  const { url, info } = await makeRequestOptions(args, options);\n  const response = await (options?.fetch ?? fetch)(url, info);\n  if (options?.retry_on_error !== false && response.status === 503 && !options?.wait_for_model) {\n    return request(args, {\n      ...options,\n      wait_for_model: true\n    });\n  }\n  if (!response.ok) {\n    if (response.headers.get(\"Content-Type\")?.startsWith(\"application/json\")) {\n      const output = await response.json();\n      if ([400, 422, 404, 500].includes(response.status) && options?.chatCompletion) {\n        throw new Error(`Server ${args.model} does not seem to support chat completion. Error: ${output.error}`);\n      }\n      if (output.error) {\n        throw new Error(JSON.stringify(output.error));\n      }\n    }\n    throw new Error(\"An error occurred while fetching the blob\");\n  }\n  if (response.headers.get(\"Content-Type\")?.startsWith(\"application/json\")) {\n    return await response.json();\n  }\n  return await response.blob();\n}\n\n// src/vendor/fetch-event-source/parse.ts\nfunction getLines(onLine) {\n  let buffer;\n  let position;\n  let fieldLength;\n  let discardTrailingNewline = false;\n  return function onChunk(arr) {\n    if (buffer === void 0) {\n      buffer = arr;\n      position = 0;\n      fieldLength = -1;\n    } else {\n      buffer = concat(buffer, arr);\n    }\n    const bufLength = buffer.length;\n    let lineStart = 0;\n    while (position < bufLength) {\n      if (discardTrailingNewline) {\n        if (buffer[position] === 10 /* NewLine */) {\n          lineStart = ++position;\n        }\n        discardTrailingNewline = false;\n      }\n      let lineEnd = -1;\n      for (; position < bufLength && lineEnd === -1; ++position) {\n        switch (buffer[position]) {\n          case 58 /* Colon */:\n            if (fieldLength === -1) {\n              fieldLength = position - lineStart;\n            }\n            break;\n          case 13 /* CarriageReturn */:\n            discardTrailingNewline = true;\n          case 10 /* NewLine */:\n            lineEnd = position;\n            break;\n        }\n      }\n      if (lineEnd === -1) {\n        break;\n      }\n      onLine(buffer.subarray(lineStart, lineEnd), fieldLength);\n      lineStart = position;\n      fieldLength = -1;\n    }\n    if (lineStart === bufLength) {\n      buffer = void 0;\n    } else if (lineStart !== 0) {\n      buffer = buffer.subarray(lineStart);\n      position -= lineStart;\n    }\n  };\n}\nfunction getMessages(onId, onRetry, onMessage) {\n  let message = newMessage();\n  const decoder = new TextDecoder();\n  return function onLine(line, fieldLength) {\n    if (line.length === 0) {\n      onMessage?.(message);\n      message = newMessage();\n    } else if (fieldLength > 0) {\n      const field = decoder.decode(line.subarray(0, fieldLength));\n      const valueOffset = fieldLength + (line[fieldLength + 1] === 32 /* Space */ ? 2 : 1);\n      const value = decoder.decode(line.subarray(valueOffset));\n      switch (field) {\n        case \"data\":\n          message.data = message.data ? message.data + \"\\n\" + value : value;\n          break;\n        case \"event\":\n          message.event = value;\n          break;\n        case \"id\":\n          onId(message.id = value);\n          break;\n        case \"retry\":\n          const retry = parseInt(value, 10);\n          if (!isNaN(retry)) {\n            onRetry(message.retry = retry);\n          }\n          break;\n      }\n    }\n  };\n}\nfunction concat(a, b) {\n  const res = new Uint8Array(a.length + b.length);\n  res.set(a);\n  res.set(b, a.length);\n  return res;\n}\nfunction newMessage() {\n  return {\n    data: \"\",\n    event: \"\",\n    id: \"\",\n    retry: void 0\n  };\n}\n\n// src/tasks/custom/streamingRequest.ts\nasync function* streamingRequest(args, options) {\n  const { url, info } = await makeRequestOptions({ ...args, stream: true }, options);\n  const response = await (options?.fetch ?? fetch)(url, info);\n  if (options?.retry_on_error !== false && response.status === 503 && !options?.wait_for_model) {\n    return yield* streamingRequest(args, {\n      ...options,\n      wait_for_model: true\n    });\n  }\n  if (!response.ok) {\n    if (response.headers.get(\"Content-Type\")?.startsWith(\"application/json\")) {\n      const output = await response.json();\n      if ([400, 422, 404, 500].includes(response.status) && options?.chatCompletion) {\n        throw new Error(`Server ${args.model} does not seem to support chat completion. Error: ${output.error}`);\n      }\n      if (output.error) {\n        throw new Error(output.error);\n      }\n    }\n    throw new Error(`Server response contains error: ${response.status}`);\n  }\n  if (!response.headers.get(\"content-type\")?.startsWith(\"text/event-stream\")) {\n    throw new Error(\n      `Server does not support event stream content type, it returned ` + response.headers.get(\"content-type\")\n    );\n  }\n  if (!response.body) {\n    return;\n  }\n  const reader = response.body.getReader();\n  let events = [];\n  const onEvent = (event) => {\n    events.push(event);\n  };\n  const onChunk = getLines(\n    getMessages(\n      () => {\n      },\n      () => {\n      },\n      onEvent\n    )\n  );\n  try {\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done)\n        return;\n      onChunk(value);\n      for (const event of events) {\n        if (event.data.length > 0) {\n          if (event.data === \"[DONE]\") {\n            return;\n          }\n          const data = JSON.parse(event.data);\n          if (typeof data === \"object\" && data !== null && \"error\" in data) {\n            throw new Error(data.error);\n          }\n          yield data;\n        }\n      }\n      events = [];\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n\n// src/lib/InferenceOutputError.ts\nvar InferenceOutputError = class extends TypeError {\n  constructor(message) {\n    super(\n      `Invalid inference output: ${message}. Use the 'request' method with the same parameters to do a custom call with no type checking.`\n    );\n    this.name = \"InferenceOutputError\";\n  }\n};\n\n// src/tasks/audio/audioClassification.ts\nasync function audioClassification(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"audio-classification\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x.label === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/audio/automaticSpeechRecognition.ts\nasync function automaticSpeechRecognition(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"automatic-speech-recognition\"\n  });\n  const isValidOutput = typeof res?.text === \"string\";\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected {text: string}\");\n  }\n  return res;\n}\n\n// src/tasks/audio/textToSpeech.ts\nasync function textToSpeech(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"text-to-speech\"\n  });\n  const isValidOutput = res && res instanceof Blob;\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Blob\");\n  }\n  return res;\n}\n\n// src/tasks/audio/audioToAudio.ts\nasync function audioToAudio(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"audio-to-audio\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(\n    (x) => typeof x.label === \"string\" && typeof x.blob === \"string\" && typeof x[\"content-type\"] === \"string\"\n  );\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, blob: string, content-type: string}>\");\n  }\n  return res;\n}\n\n// src/tasks/cv/imageClassification.ts\nasync function imageClassification(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"image-classification\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x.label === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/cv/imageSegmentation.ts\nasync function imageSegmentation(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"image-segmentation\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x.label === \"string\" && typeof x.mask === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, mask: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/cv/imageToText.ts\nasync function imageToText(args, options) {\n  const res = (await request(args, {\n    ...options,\n    taskHint: \"image-to-text\"\n  }))?.[0];\n  if (typeof res?.generated_text !== \"string\") {\n    throw new InferenceOutputError(\"Expected {generated_text: string}\");\n  }\n  return res;\n}\n\n// src/tasks/cv/objectDetection.ts\nasync function objectDetection(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"object-detection\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(\n    (x) => typeof x.label === \"string\" && typeof x.score === \"number\" && typeof x.box.xmin === \"number\" && typeof x.box.ymin === \"number\" && typeof x.box.xmax === \"number\" && typeof x.box.ymax === \"number\"\n  );\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\n      \"Expected Array<{label:string; score:number; box:{xmin:number; ymin:number; xmax:number; ymax:number}}>\"\n    );\n  }\n  return res;\n}\n\n// src/tasks/cv/textToImage.ts\nasync function textToImage(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"text-to-image\"\n  });\n  const isValidOutput = res && res instanceof Blob;\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Blob\");\n  }\n  return res;\n}\n\n// src/utils/base64FromBytes.ts\nfunction base64FromBytes(arr) {\n  if (globalThis.Buffer) {\n    return globalThis.Buffer.from(arr).toString(\"base64\");\n  } else {\n    const bin = [];\n    arr.forEach((byte) => {\n      bin.push(String.fromCharCode(byte));\n    });\n    return globalThis.btoa(bin.join(\"\"));\n  }\n}\n\n// src/tasks/cv/imageToImage.ts\nasync function imageToImage(args, options) {\n  let reqArgs;\n  if (!args.parameters) {\n    reqArgs = {\n      accessToken: args.accessToken,\n      model: args.model,\n      data: args.inputs\n    };\n  } else {\n    reqArgs = {\n      ...args,\n      inputs: base64FromBytes(\n        new Uint8Array(args.inputs instanceof ArrayBuffer ? args.inputs : await args.inputs.arrayBuffer())\n      )\n    };\n  }\n  const res = await request(reqArgs, {\n    ...options,\n    taskHint: \"image-to-image\"\n  });\n  const isValidOutput = res && res instanceof Blob;\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Blob\");\n  }\n  return res;\n}\n\n// src/tasks/cv/zeroShotImageClassification.ts\nasync function zeroShotImageClassification(args, options) {\n  const reqArgs = {\n    ...args,\n    inputs: {\n      image: base64FromBytes(\n        new Uint8Array(\n          args.inputs.image instanceof ArrayBuffer ? args.inputs.image : await args.inputs.image.arrayBuffer()\n        )\n      )\n    }\n  };\n  const res = await request(reqArgs, {\n    ...options,\n    taskHint: \"zero-shot-image-classification\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x.label === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/featureExtraction.ts\nasync function featureExtraction(args, options) {\n  const defaultTask = args.model ? await getDefaultTask(args.model, args.accessToken, options) : void 0;\n  const res = await request(args, {\n    ...options,\n    taskHint: \"feature-extraction\",\n    ...defaultTask === \"sentence-similarity\" && { forceTask: \"feature-extraction\" }\n  });\n  let isValidOutput = true;\n  const isNumArrayRec = (arr, maxDepth, curDepth = 0) => {\n    if (curDepth > maxDepth)\n      return false;\n    if (arr.every((x) => Array.isArray(x))) {\n      return arr.every((x) => isNumArrayRec(x, maxDepth, curDepth + 1));\n    } else {\n      return arr.every((x) => typeof x === \"number\");\n    }\n  };\n  isValidOutput = Array.isArray(res) && isNumArrayRec(res, 3, 0);\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<number[][][] | number[][] | number[] | number>\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/fillMask.ts\nasync function fillMask(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"fill-mask\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(\n    (x) => typeof x.score === \"number\" && typeof x.sequence === \"string\" && typeof x.token === \"number\" && typeof x.token_str === \"string\"\n  );\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\n      \"Expected Array<{score: number, sequence: string, token: number, token_str: string}>\"\n    );\n  }\n  return res;\n}\n\n// src/tasks/nlp/questionAnswering.ts\nasync function questionAnswering(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"question-answering\"\n  });\n  const isValidOutput = typeof res === \"object\" && !!res && typeof res.answer === \"string\" && typeof res.end === \"number\" && typeof res.score === \"number\" && typeof res.start === \"number\";\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected {answer: string, end: number, score: number, start: number}\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/sentenceSimilarity.ts\nasync function sentenceSimilarity(args, options) {\n  const defaultTask = args.model ? await getDefaultTask(args.model, args.accessToken, options) : void 0;\n  const res = await request(args, {\n    ...options,\n    taskHint: \"sentence-similarity\",\n    ...defaultTask === \"feature-extraction\" && { forceTask: \"sentence-similarity\" }\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected number[]\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/summarization.ts\nasync function summarization(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"summarization\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x?.summary_text === \"string\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{summary_text: string}>\");\n  }\n  return res?.[0];\n}\n\n// src/tasks/nlp/tableQuestionAnswering.ts\nasync function tableQuestionAnswering(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"table-question-answering\"\n  });\n  const isValidOutput = typeof res?.aggregator === \"string\" && typeof res.answer === \"string\" && Array.isArray(res.cells) && res.cells.every((x) => typeof x === \"string\") && Array.isArray(res.coordinates) && res.coordinates.every((coord) => Array.isArray(coord) && coord.every((x) => typeof x === \"number\"));\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\n      \"Expected {aggregator: string, answer: string, cells: string[], coordinates: number[][]}\"\n    );\n  }\n  return res;\n}\n\n// src/tasks/nlp/textClassification.ts\nasync function textClassification(args, options) {\n  const res = (await request(args, {\n    ...options,\n    taskHint: \"text-classification\"\n  }))?.[0];\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x?.label === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/utils/toArray.ts\nfunction toArray(obj) {\n  if (Array.isArray(obj)) {\n    return obj;\n  }\n  return [obj];\n}\n\n// src/tasks/nlp/textGeneration.ts\nasync function textGeneration(args, options) {\n  const res = toArray(\n    await request(args, {\n      ...options,\n      taskHint: \"text-generation\"\n    })\n  );\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x?.generated_text === \"string\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{generated_text: string}>\");\n  }\n  return res?.[0];\n}\n\n// src/tasks/nlp/textGenerationStream.ts\nasync function* textGenerationStream(args, options) {\n  yield* streamingRequest(args, {\n    ...options,\n    taskHint: \"text-generation\"\n  });\n}\n\n// src/tasks/nlp/tokenClassification.ts\nasync function tokenClassification(args, options) {\n  const res = toArray(\n    await request(args, {\n      ...options,\n      taskHint: \"token-classification\"\n    })\n  );\n  const isValidOutput = Array.isArray(res) && res.every(\n    (x) => typeof x.end === \"number\" && typeof x.entity_group === \"string\" && typeof x.score === \"number\" && typeof x.start === \"number\" && typeof x.word === \"string\"\n  );\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\n      \"Expected Array<{end: number, entity_group: string, score: number, start: number, word: string}>\"\n    );\n  }\n  return res;\n}\n\n// src/tasks/nlp/translation.ts\nasync function translation(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"translation\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x?.translation_text === \"string\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected type Array<{translation_text: string}>\");\n  }\n  return res?.length === 1 ? res?.[0] : res;\n}\n\n// src/tasks/nlp/zeroShotClassification.ts\nasync function zeroShotClassification(args, options) {\n  const res = toArray(\n    await request(args, {\n      ...options,\n      taskHint: \"zero-shot-classification\"\n    })\n  );\n  const isValidOutput = Array.isArray(res) && res.every(\n    (x) => Array.isArray(x.labels) && x.labels.every((_label) => typeof _label === \"string\") && Array.isArray(x.scores) && x.scores.every((_score) => typeof _score === \"number\") && typeof x.sequence === \"string\"\n  );\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{labels: string[], scores: number[], sequence: string}>\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/chatCompletion.ts\nasync function chatCompletion(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"text-generation\",\n    chatCompletion: true\n  });\n  const isValidOutput = typeof res === \"object\" && Array.isArray(res?.choices) && typeof res?.created === \"number\" && typeof res?.id === \"string\" && typeof res?.model === \"string\" && typeof res?.system_fingerprint === \"string\" && typeof res?.usage === \"object\";\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected ChatCompletionOutput\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/chatCompletionStream.ts\nasync function* chatCompletionStream(args, options) {\n  yield* streamingRequest(args, {\n    ...options,\n    taskHint: \"text-generation\",\n    chatCompletion: true\n  });\n}\n\n// src/tasks/multimodal/documentQuestionAnswering.ts\nasync function documentQuestionAnswering(args, options) {\n  const reqArgs = {\n    ...args,\n    inputs: {\n      question: args.inputs.question,\n      // convert Blob or ArrayBuffer to base64\n      image: base64FromBytes(\n        new Uint8Array(\n          args.inputs.image instanceof ArrayBuffer ? args.inputs.image : await args.inputs.image.arrayBuffer()\n        )\n      )\n    }\n  };\n  const res = toArray(\n    await request(reqArgs, {\n      ...options,\n      taskHint: \"document-question-answering\"\n    })\n  )?.[0];\n  const isValidOutput = typeof res?.answer === \"string\" && (typeof res.end === \"number\" || typeof res.end === \"undefined\") && (typeof res.score === \"number\" || typeof res.score === \"undefined\") && (typeof res.start === \"number\" || typeof res.start === \"undefined\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{answer: string, end?: number, score?: number, start?: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/multimodal/visualQuestionAnswering.ts\nasync function visualQuestionAnswering(args, options) {\n  const reqArgs = {\n    ...args,\n    inputs: {\n      question: args.inputs.question,\n      // convert Blob or ArrayBuffer to base64\n      image: base64FromBytes(\n        new Uint8Array(\n          args.inputs.image instanceof ArrayBuffer ? args.inputs.image : await args.inputs.image.arrayBuffer()\n        )\n      )\n    }\n  };\n  const res = (await request(reqArgs, {\n    ...options,\n    taskHint: \"visual-question-answering\"\n  }))?.[0];\n  const isValidOutput = typeof res?.answer === \"string\" && typeof res.score === \"number\";\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{answer: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/tabular/tabularRegression.ts\nasync function tabularRegression(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"tabular-regression\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected number[]\");\n  }\n  return res;\n}\n\n// src/tasks/tabular/tabularClassification.ts\nasync function tabularClassification(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"tabular-classification\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected number[]\");\n  }\n  return res;\n}\n\n// src/HfInference.ts\nvar HfInference = class {\n  accessToken;\n  defaultOptions;\n  constructor(accessToken = \"\", defaultOptions = {}) {\n    this.accessToken = accessToken;\n    this.defaultOptions = defaultOptions;\n    for (const [name, fn] of Object.entries(tasks_exports)) {\n      Object.defineProperty(this, name, {\n        enumerable: false,\n        value: (params, options) => (\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          fn({ ...params, accessToken }, { ...defaultOptions, ...options })\n        )\n      });\n    }\n  }\n  /**\n   * Returns copy of HfInference tied to a specified endpoint.\n   */\n  endpoint(endpointUrl) {\n    return new HfInferenceEndpoint(endpointUrl, this.accessToken, this.defaultOptions);\n  }\n};\nvar HfInferenceEndpoint = class {\n  constructor(endpointUrl, accessToken = \"\", defaultOptions = {}) {\n    accessToken;\n    defaultOptions;\n    for (const [name, fn] of Object.entries(tasks_exports)) {\n      Object.defineProperty(this, name, {\n        enumerable: false,\n        value: (params, options) => (\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          fn({ ...params, accessToken, endpointUrl }, { ...defaultOptions, ...options })\n        )\n      });\n    }\n  }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGh1Z2dpbmdmYWNlL2luZmVyZW5jZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsTUFBTSxHQUFHLFlBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFdBQVcsY0FBYyxNQUFNO0FBQ3hGLCtCQUErQix5QkFBeUIsWUFBWSxJQUFJO0FBQ3hFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIseUJBQXlCLG1EQUFtRDtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHlDQUF5QztBQUNuRCxRQUFRLFFBQVE7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EseUNBQXlDLFlBQVk7QUFDckQ7QUFDQTtBQUNBLCtCQUEr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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUNBQXFDLElBQUksK0JBQStCO0FBQ3ZGO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQW9DRSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9AaHVnZ2luZ2ZhY2UvaW5mZXJlbmNlL2Rpc3QvaW5kZXguanM/ODc0ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xuXG4vLyBzcmMvdGFza3MvaW5kZXgudHNcbnZhciB0YXNrc19leHBvcnRzID0ge307XG5fX2V4cG9ydCh0YXNrc19leHBvcnRzLCB7XG4gIGF1ZGlvQ2xhc3NpZmljYXRpb246ICgpID0+IGF1ZGlvQ2xhc3NpZmljYXRpb24sXG4gIGF1ZGlvVG9BdWRpbzogKCkgPT4gYXVkaW9Ub0F1ZGlvLFxuICBhdXRvbWF0aWNTcGVlY2hSZWNvZ25pdGlvbjogKCkgPT4gYXV0b21hdGljU3BlZWNoUmVjb2duaXRpb24sXG4gIGNoYXRDb21wbGV0aW9uOiAoKSA9PiBjaGF0Q29tcGxldGlvbixcbiAgY2hhdENvbXBsZXRpb25TdHJlYW06ICgpID0+IGNoYXRDb21wbGV0aW9uU3RyZWFtLFxuICBkb2N1bWVudFF1ZXN0aW9uQW5zd2VyaW5nOiAoKSA9PiBkb2N1bWVudFF1ZXN0aW9uQW5zd2VyaW5nLFxuICBmZWF0dXJlRXh0cmFjdGlvbjogKCkgPT4gZmVhdHVyZUV4dHJhY3Rpb24sXG4gIGZpbGxNYXNrOiAoKSA9PiBmaWxsTWFzayxcbiAgaW1hZ2VDbGFzc2lmaWNhdGlvbjogKCkgPT4gaW1hZ2VDbGFzc2lmaWNhdGlvbixcbiAgaW1hZ2VTZWdtZW50YXRpb246ICgpID0+IGltYWdlU2VnbWVudGF0aW9uLFxuICBpbWFnZVRvSW1hZ2U6ICgpID0+IGltYWdlVG9JbWFnZSxcbiAgaW1hZ2VUb1RleHQ6ICgpID0+IGltYWdlVG9UZXh0LFxuICBvYmplY3REZXRlY3Rpb246ICgpID0+IG9iamVjdERldGVjdGlvbixcbiAgcXVlc3Rpb25BbnN3ZXJpbmc6ICgpID0+IHF1ZXN0aW9uQW5zd2VyaW5nLFxuICByZXF1ZXN0OiAoKSA9PiByZXF1ZXN0LFxuICBzZW50ZW5jZVNpbWlsYXJpdHk6ICgpID0+IHNlbnRlbmNlU2ltaWxhcml0eSxcbiAgc3RyZWFtaW5nUmVxdWVzdDogKCkgPT4gc3RyZWFtaW5nUmVxdWVzdCxcbiAgc3VtbWFyaXphdGlvbjogKCkgPT4gc3VtbWFyaXphdGlvbixcbiAgdGFibGVRdWVzdGlvbkFuc3dlcmluZzogKCkgPT4gdGFibGVRdWVzdGlvbkFuc3dlcmluZyxcbiAgdGFidWxhckNsYXNzaWZpY2F0aW9uOiAoKSA9PiB0YWJ1bGFyQ2xhc3NpZmljYXRpb24sXG4gIHRhYnVsYXJSZWdyZXNzaW9uOiAoKSA9PiB0YWJ1bGFyUmVncmVzc2lvbixcbiAgdGV4dENsYXNzaWZpY2F0aW9uOiAoKSA9PiB0ZXh0Q2xhc3NpZmljYXRpb24sXG4gIHRleHRHZW5lcmF0aW9uOiAoKSA9PiB0ZXh0R2VuZXJhdGlvbixcbiAgdGV4dEdlbmVyYXRpb25TdHJlYW06ICgpID0+IHRleHRHZW5lcmF0aW9uU3RyZWFtLFxuICB0ZXh0VG9JbWFnZTogKCkgPT4gdGV4dFRvSW1hZ2UsXG4gIHRleHRUb1NwZWVjaDogKCkgPT4gdGV4dFRvU3BlZWNoLFxuICB0b2tlbkNsYXNzaWZpY2F0aW9uOiAoKSA9PiB0b2tlbkNsYXNzaWZpY2F0aW9uLFxuICB0cmFuc2xhdGlvbjogKCkgPT4gdHJhbnNsYXRpb24sXG4gIHZpc3VhbFF1ZXN0aW9uQW5zd2VyaW5nOiAoKSA9PiB2aXN1YWxRdWVzdGlvbkFuc3dlcmluZyxcbiAgemVyb1Nob3RDbGFzc2lmaWNhdGlvbjogKCkgPT4gemVyb1Nob3RDbGFzc2lmaWNhdGlvbixcbiAgemVyb1Nob3RJbWFnZUNsYXNzaWZpY2F0aW9uOiAoKSA9PiB6ZXJvU2hvdEltYWdlQ2xhc3NpZmljYXRpb25cbn0pO1xuXG4vLyBzcmMvdXRpbHMvcGljay50c1xuZnVuY3Rpb24gcGljayhvLCBwcm9wcykge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICB7fSxcbiAgICAuLi5wcm9wcy5tYXAoKHByb3ApID0+IHtcbiAgICAgIGlmIChvW3Byb3BdICE9PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIHsgW3Byb3BdOiBvW3Byb3BdIH07XG4gICAgICB9XG4gICAgfSlcbiAgKTtcbn1cblxuLy8gc3JjL3V0aWxzL3R5cGVkSW5jbHVkZS50c1xuZnVuY3Rpb24gdHlwZWRJbmNsdWRlKGFyciwgdikge1xuICByZXR1cm4gYXJyLmluY2x1ZGVzKHYpO1xufVxuXG4vLyBzcmMvdXRpbHMvb21pdC50c1xuZnVuY3Rpb24gb21pdChvLCBwcm9wcykge1xuICBjb25zdCBwcm9wc0FyciA9IEFycmF5LmlzQXJyYXkocHJvcHMpID8gcHJvcHMgOiBbcHJvcHNdO1xuICBjb25zdCBsZXRzS2VlcCA9IE9iamVjdC5rZXlzKG8pLmZpbHRlcigocHJvcCkgPT4gIXR5cGVkSW5jbHVkZShwcm9wc0FyciwgcHJvcCkpO1xuICByZXR1cm4gcGljayhvLCBsZXRzS2VlcCk7XG59XG5cbi8vIHNyYy9saWIvaXNVcmwudHNcbmZ1bmN0aW9uIGlzVXJsKG1vZGVsT3JVcmwpIHtcbiAgcmV0dXJuIC9eaHR0cChzPyk6Ly50ZXN0KG1vZGVsT3JVcmwpIHx8IG1vZGVsT3JVcmwuc3RhcnRzV2l0aChcIi9cIik7XG59XG5cbi8vIHNyYy9saWIvZ2V0RGVmYXVsdFRhc2sudHNcbnZhciB0YXNrQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xudmFyIENBQ0hFX0RVUkFUSU9OID0gMTAgKiA2MCAqIDFlMztcbnZhciBNQVhfQ0FDSEVfSVRFTVMgPSAxZTM7XG52YXIgSEZfSFVCX1VSTCA9IFwiaHR0cHM6Ly9odWdnaW5nZmFjZS5jb1wiO1xuYXN5bmMgZnVuY3Rpb24gZ2V0RGVmYXVsdFRhc2sobW9kZWwsIGFjY2Vzc1Rva2VuLCBvcHRpb25zKSB7XG4gIGlmIChpc1VybChtb2RlbCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBrZXkgPSBgJHttb2RlbH06JHthY2Nlc3NUb2tlbn1gO1xuICBsZXQgY2FjaGVkVGFzayA9IHRhc2tDYWNoZS5nZXQoa2V5KTtcbiAgaWYgKGNhY2hlZFRhc2sgJiYgY2FjaGVkVGFzay5kYXRlIDwgbmV3IERhdGUoRGF0ZS5ub3coKSAtIENBQ0hFX0RVUkFUSU9OKSkge1xuICAgIHRhc2tDYWNoZS5kZWxldGUoa2V5KTtcbiAgICBjYWNoZWRUYXNrID0gdm9pZCAwO1xuICB9XG4gIGlmIChjYWNoZWRUYXNrID09PSB2b2lkIDApIHtcbiAgICBjb25zdCBtb2RlbFRhc2sgPSBhd2FpdCAob3B0aW9ucz8uZmV0Y2ggPz8gZmV0Y2gpKGAke0hGX0hVQl9VUkx9L2FwaS9tb2RlbHMvJHttb2RlbH0/ZXhwYW5kW109cGlwZWxpbmVfdGFnYCwge1xuICAgICAgaGVhZGVyczogYWNjZXNzVG9rZW4gPyB7IEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHthY2Nlc3NUb2tlbn1gIH0gOiB7fVxuICAgIH0pLnRoZW4oKHJlc3ApID0+IHJlc3AuanNvbigpKS50aGVuKChqc29uKSA9PiBqc29uLnBpcGVsaW5lX3RhZykuY2F0Y2goKCkgPT4gbnVsbCk7XG4gICAgaWYgKCFtb2RlbFRhc2spIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjYWNoZWRUYXNrID0geyB0YXNrOiBtb2RlbFRhc2ssIGRhdGU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpIH07XG4gICAgdGFza0NhY2hlLnNldChrZXksIHsgdGFzazogbW9kZWxUYXNrLCBkYXRlOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSB9KTtcbiAgICBpZiAodGFza0NhY2hlLnNpemUgPiBNQVhfQ0FDSEVfSVRFTVMpIHtcbiAgICAgIHRhc2tDYWNoZS5kZWxldGUodGFza0NhY2hlLmtleXMoKS5uZXh0KCkudmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2FjaGVkVGFzay50YXNrO1xufVxuXG4vLyBzcmMvbGliL21ha2VSZXF1ZXN0T3B0aW9ucy50c1xudmFyIEhGX0lORkVSRU5DRV9BUElfQkFTRV9VUkwgPSBcImh0dHBzOi8vYXBpLWluZmVyZW5jZS5odWdnaW5nZmFjZS5jb1wiO1xudmFyIHRhc2tzID0gbnVsbDtcbmFzeW5jIGZ1bmN0aW9uIG1ha2VSZXF1ZXN0T3B0aW9ucyhhcmdzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgYWNjZXNzVG9rZW4sIGVuZHBvaW50VXJsLCAuLi5vdGhlckFyZ3MgfSA9IGFyZ3M7XG4gIGxldCB7IG1vZGVsIH0gPSBhcmdzO1xuICBjb25zdCB7XG4gICAgZm9yY2VUYXNrOiB0YXNrLFxuICAgIGluY2x1ZGVDcmVkZW50aWFscyxcbiAgICB0YXNrSGludCxcbiAgICB3YWl0X2Zvcl9tb2RlbCxcbiAgICB1c2VfY2FjaGUsXG4gICAgZG9udF9sb2FkX21vZGVsLFxuICAgIGNoYXRDb21wbGV0aW9uOiBjaGF0Q29tcGxldGlvbjJcbiAgfSA9IG9wdGlvbnMgPz8ge307XG4gIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgaWYgKGFjY2Vzc1Rva2VuKSB7XG4gICAgaGVhZGVyc1tcIkF1dGhvcml6YXRpb25cIl0gPSBgQmVhcmVyICR7YWNjZXNzVG9rZW59YDtcbiAgfVxuICBpZiAoIW1vZGVsICYmICF0YXNrcyAmJiB0YXNrSGludCkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAke0hGX0hVQl9VUkx9L2FwaS90YXNrc2ApO1xuICAgIGlmIChyZXMub2spIHtcbiAgICAgIHRhc2tzID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFtb2RlbCAmJiB0YXNrcyAmJiB0YXNrSGludCkge1xuICAgIGNvbnN0IHRhc2tJbmZvID0gdGFza3NbdGFza0hpbnRdO1xuICAgIGlmICh0YXNrSW5mbykge1xuICAgICAgbW9kZWwgPSB0YXNrSW5mby5tb2RlbHNbMF0uaWQ7XG4gICAgfVxuICB9XG4gIGlmICghbW9kZWwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBtb2RlbCBwcm92aWRlZCwgYW5kIG5vIGRlZmF1bHQgbW9kZWwgZm91bmQgZm9yIHRoaXMgdGFza1wiKTtcbiAgfVxuICBjb25zdCBiaW5hcnkgPSBcImRhdGFcIiBpbiBhcmdzICYmICEhYXJncy5kYXRhO1xuICBpZiAoIWJpbmFyeSkge1xuICAgIGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPSBcImFwcGxpY2F0aW9uL2pzb25cIjtcbiAgfVxuICBpZiAod2FpdF9mb3JfbW9kZWwpIHtcbiAgICBoZWFkZXJzW1wiWC1XYWl0LUZvci1Nb2RlbFwiXSA9IFwidHJ1ZVwiO1xuICB9XG4gIGlmICh1c2VfY2FjaGUgPT09IGZhbHNlKSB7XG4gICAgaGVhZGVyc1tcIlgtVXNlLUNhY2hlXCJdID0gXCJmYWxzZVwiO1xuICB9XG4gIGlmIChkb250X2xvYWRfbW9kZWwpIHtcbiAgICBoZWFkZXJzW1wiWC1Mb2FkLU1vZGVsXCJdID0gXCIwXCI7XG4gIH1cbiAgbGV0IHVybCA9ICgoKSA9PiB7XG4gICAgaWYgKGVuZHBvaW50VXJsICYmIGlzVXJsKG1vZGVsKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkJvdGggbW9kZWwgYW5kIGVuZHBvaW50VXJsIGNhbm5vdCBiZSBVUkxzXCIpO1xuICAgIH1cbiAgICBpZiAoaXNVcmwobW9kZWwpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJVc2luZyBhIG1vZGVsIFVSTCBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIHRoZSBgZW5kcG9pbnRVcmxgIHBhcmFtZXRlciBpbnN0ZWFkXCIpO1xuICAgICAgcmV0dXJuIG1vZGVsO1xuICAgIH1cbiAgICBpZiAoZW5kcG9pbnRVcmwpIHtcbiAgICAgIHJldHVybiBlbmRwb2ludFVybDtcbiAgICB9XG4gICAgaWYgKHRhc2spIHtcbiAgICAgIHJldHVybiBgJHtIRl9JTkZFUkVOQ0VfQVBJX0JBU0VfVVJMfS9waXBlbGluZS8ke3Rhc2t9LyR7bW9kZWx9YDtcbiAgICB9XG4gICAgcmV0dXJuIGAke0hGX0lORkVSRU5DRV9BUElfQkFTRV9VUkx9L21vZGVscy8ke21vZGVsfWA7XG4gIH0pKCk7XG4gIGlmIChjaGF0Q29tcGxldGlvbjIgJiYgIXVybC5lbmRzV2l0aChcIi9jaGF0L2NvbXBsZXRpb25zXCIpKSB7XG4gICAgdXJsICs9IFwiL3YxL2NoYXQvY29tcGxldGlvbnNcIjtcbiAgfVxuICBsZXQgY3JlZGVudGlhbHM7XG4gIGlmICh0eXBlb2YgaW5jbHVkZUNyZWRlbnRpYWxzID09PSBcInN0cmluZ1wiKSB7XG4gICAgY3JlZGVudGlhbHMgPSBpbmNsdWRlQ3JlZGVudGlhbHM7XG4gIH0gZWxzZSBpZiAoaW5jbHVkZUNyZWRlbnRpYWxzID09PSB0cnVlKSB7XG4gICAgY3JlZGVudGlhbHMgPSBcImluY2x1ZGVcIjtcbiAgfVxuICBjb25zdCBpbmZvID0ge1xuICAgIGhlYWRlcnMsXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiBiaW5hcnkgPyBhcmdzLmRhdGEgOiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAuLi5vdGhlckFyZ3MubW9kZWwgJiYgaXNVcmwob3RoZXJBcmdzLm1vZGVsKSA/IG9taXQob3RoZXJBcmdzLCBcIm1vZGVsXCIpIDogb3RoZXJBcmdzXG4gICAgfSksXG4gICAgLi4uY3JlZGVudGlhbHMgJiYgeyBjcmVkZW50aWFscyB9LFxuICAgIHNpZ25hbDogb3B0aW9ucz8uc2lnbmFsXG4gIH07XG4gIHJldHVybiB7IHVybCwgaW5mbyB9O1xufVxuXG4vLyBzcmMvdGFza3MvY3VzdG9tL3JlcXVlc3QudHNcbmFzeW5jIGZ1bmN0aW9uIHJlcXVlc3QoYXJncywgb3B0aW9ucykge1xuICBjb25zdCB7IHVybCwgaW5mbyB9ID0gYXdhaXQgbWFrZVJlcXVlc3RPcHRpb25zKGFyZ3MsIG9wdGlvbnMpO1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IChvcHRpb25zPy5mZXRjaCA/PyBmZXRjaCkodXJsLCBpbmZvKTtcbiAgaWYgKG9wdGlvbnM/LnJldHJ5X29uX2Vycm9yICE9PSBmYWxzZSAmJiByZXNwb25zZS5zdGF0dXMgPT09IDUwMyAmJiAhb3B0aW9ucz8ud2FpdF9mb3JfbW9kZWwpIHtcbiAgICByZXR1cm4gcmVxdWVzdChhcmdzLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgd2FpdF9mb3JfbW9kZWw6IHRydWVcbiAgICB9KTtcbiAgfVxuICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgaWYgKHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiQ29udGVudC1UeXBlXCIpPy5zdGFydHNXaXRoKFwiYXBwbGljYXRpb24vanNvblwiKSkge1xuICAgICAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgaWYgKFs0MDAsIDQyMiwgNDA0LCA1MDBdLmluY2x1ZGVzKHJlc3BvbnNlLnN0YXR1cykgJiYgb3B0aW9ucz8uY2hhdENvbXBsZXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTZXJ2ZXIgJHthcmdzLm1vZGVsfSBkb2VzIG5vdCBzZWVtIHRvIHN1cHBvcnQgY2hhdCBjb21wbGV0aW9uLiBFcnJvcjogJHtvdXRwdXQuZXJyb3J9YCk7XG4gICAgICB9XG4gICAgICBpZiAob3V0cHV0LmVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeShvdXRwdXQuZXJyb3IpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgZmV0Y2hpbmcgdGhlIGJsb2JcIik7XG4gIH1cbiAgaWYgKHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiQ29udGVudC1UeXBlXCIpPy5zdGFydHNXaXRoKFwiYXBwbGljYXRpb24vanNvblwiKSkge1xuICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gIH1cbiAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmJsb2IoKTtcbn1cblxuLy8gc3JjL3ZlbmRvci9mZXRjaC1ldmVudC1zb3VyY2UvcGFyc2UudHNcbmZ1bmN0aW9uIGdldExpbmVzKG9uTGluZSkge1xuICBsZXQgYnVmZmVyO1xuICBsZXQgcG9zaXRpb247XG4gIGxldCBmaWVsZExlbmd0aDtcbiAgbGV0IGRpc2NhcmRUcmFpbGluZ05ld2xpbmUgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uIG9uQ2h1bmsoYXJyKSB7XG4gICAgaWYgKGJ1ZmZlciA9PT0gdm9pZCAwKSB7XG4gICAgICBidWZmZXIgPSBhcnI7XG4gICAgICBwb3NpdGlvbiA9IDA7XG4gICAgICBmaWVsZExlbmd0aCA9IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICBidWZmZXIgPSBjb25jYXQoYnVmZmVyLCBhcnIpO1xuICAgIH1cbiAgICBjb25zdCBidWZMZW5ndGggPSBidWZmZXIubGVuZ3RoO1xuICAgIGxldCBsaW5lU3RhcnQgPSAwO1xuICAgIHdoaWxlIChwb3NpdGlvbiA8IGJ1Zkxlbmd0aCkge1xuICAgICAgaWYgKGRpc2NhcmRUcmFpbGluZ05ld2xpbmUpIHtcbiAgICAgICAgaWYgKGJ1ZmZlcltwb3NpdGlvbl0gPT09IDEwIC8qIE5ld0xpbmUgKi8pIHtcbiAgICAgICAgICBsaW5lU3RhcnQgPSArK3Bvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGRpc2NhcmRUcmFpbGluZ05ld2xpbmUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGxldCBsaW5lRW5kID0gLTE7XG4gICAgICBmb3IgKDsgcG9zaXRpb24gPCBidWZMZW5ndGggJiYgbGluZUVuZCA9PT0gLTE7ICsrcG9zaXRpb24pIHtcbiAgICAgICAgc3dpdGNoIChidWZmZXJbcG9zaXRpb25dKSB7XG4gICAgICAgICAgY2FzZSA1OCAvKiBDb2xvbiAqLzpcbiAgICAgICAgICAgIGlmIChmaWVsZExlbmd0aCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgZmllbGRMZW5ndGggPSBwb3NpdGlvbiAtIGxpbmVTdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTMgLyogQ2FycmlhZ2VSZXR1cm4gKi86XG4gICAgICAgICAgICBkaXNjYXJkVHJhaWxpbmdOZXdsaW5lID0gdHJ1ZTtcbiAgICAgICAgICBjYXNlIDEwIC8qIE5ld0xpbmUgKi86XG4gICAgICAgICAgICBsaW5lRW5kID0gcG9zaXRpb247XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxpbmVFbmQgPT09IC0xKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgb25MaW5lKGJ1ZmZlci5zdWJhcnJheShsaW5lU3RhcnQsIGxpbmVFbmQpLCBmaWVsZExlbmd0aCk7XG4gICAgICBsaW5lU3RhcnQgPSBwb3NpdGlvbjtcbiAgICAgIGZpZWxkTGVuZ3RoID0gLTE7XG4gICAgfVxuICAgIGlmIChsaW5lU3RhcnQgPT09IGJ1Zkxlbmd0aCkge1xuICAgICAgYnVmZmVyID0gdm9pZCAwO1xuICAgIH0gZWxzZSBpZiAobGluZVN0YXJ0ICE9PSAwKSB7XG4gICAgICBidWZmZXIgPSBidWZmZXIuc3ViYXJyYXkobGluZVN0YXJ0KTtcbiAgICAgIHBvc2l0aW9uIC09IGxpbmVTdGFydDtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBnZXRNZXNzYWdlcyhvbklkLCBvblJldHJ5LCBvbk1lc3NhZ2UpIHtcbiAgbGV0IG1lc3NhZ2UgPSBuZXdNZXNzYWdlKCk7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIG9uTGluZShsaW5lLCBmaWVsZExlbmd0aCkge1xuICAgIGlmIChsaW5lLmxlbmd0aCA9PT0gMCkge1xuICAgICAgb25NZXNzYWdlPy4obWVzc2FnZSk7XG4gICAgICBtZXNzYWdlID0gbmV3TWVzc2FnZSgpO1xuICAgIH0gZWxzZSBpZiAoZmllbGRMZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBmaWVsZCA9IGRlY29kZXIuZGVjb2RlKGxpbmUuc3ViYXJyYXkoMCwgZmllbGRMZW5ndGgpKTtcbiAgICAgIGNvbnN0IHZhbHVlT2Zmc2V0ID0gZmllbGRMZW5ndGggKyAobGluZVtmaWVsZExlbmd0aCArIDFdID09PSAzMiAvKiBTcGFjZSAqLyA/IDIgOiAxKTtcbiAgICAgIGNvbnN0IHZhbHVlID0gZGVjb2Rlci5kZWNvZGUobGluZS5zdWJhcnJheSh2YWx1ZU9mZnNldCkpO1xuICAgICAgc3dpdGNoIChmaWVsZCkge1xuICAgICAgICBjYXNlIFwiZGF0YVwiOlxuICAgICAgICAgIG1lc3NhZ2UuZGF0YSA9IG1lc3NhZ2UuZGF0YSA/IG1lc3NhZ2UuZGF0YSArIFwiXFxuXCIgKyB2YWx1ZSA6IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZXZlbnRcIjpcbiAgICAgICAgICBtZXNzYWdlLmV2ZW50ID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJpZFwiOlxuICAgICAgICAgIG9uSWQobWVzc2FnZS5pZCA9IHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJldHJ5XCI6XG4gICAgICAgICAgY29uc3QgcmV0cnkgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgICAgICAgIGlmICghaXNOYU4ocmV0cnkpKSB7XG4gICAgICAgICAgICBvblJldHJ5KG1lc3NhZ2UucmV0cnkgPSByZXRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbmNhdChhLCBiKSB7XG4gIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KGEubGVuZ3RoICsgYi5sZW5ndGgpO1xuICByZXMuc2V0KGEpO1xuICByZXMuc2V0KGIsIGEubGVuZ3RoKTtcbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIG5ld01lc3NhZ2UoKSB7XG4gIHJldHVybiB7XG4gICAgZGF0YTogXCJcIixcbiAgICBldmVudDogXCJcIixcbiAgICBpZDogXCJcIixcbiAgICByZXRyeTogdm9pZCAwXG4gIH07XG59XG5cbi8vIHNyYy90YXNrcy9jdXN0b20vc3RyZWFtaW5nUmVxdWVzdC50c1xuYXN5bmMgZnVuY3Rpb24qIHN0cmVhbWluZ1JlcXVlc3QoYXJncywgb3B0aW9ucykge1xuICBjb25zdCB7IHVybCwgaW5mbyB9ID0gYXdhaXQgbWFrZVJlcXVlc3RPcHRpb25zKHsgLi4uYXJncywgc3RyZWFtOiB0cnVlIH0sIG9wdGlvbnMpO1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IChvcHRpb25zPy5mZXRjaCA/PyBmZXRjaCkodXJsLCBpbmZvKTtcbiAgaWYgKG9wdGlvbnM/LnJldHJ5X29uX2Vycm9yICE9PSBmYWxzZSAmJiByZXNwb25zZS5zdGF0dXMgPT09IDUwMyAmJiAhb3B0aW9ucz8ud2FpdF9mb3JfbW9kZWwpIHtcbiAgICByZXR1cm4geWllbGQqIHN0cmVhbWluZ1JlcXVlc3QoYXJncywge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHdhaXRfZm9yX21vZGVsOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgIGlmIChyZXNwb25zZS5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKT8uc3RhcnRzV2l0aChcImFwcGxpY2F0aW9uL2pzb25cIikpIHtcbiAgICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIGlmIChbNDAwLCA0MjIsIDQwNCwgNTAwXS5pbmNsdWRlcyhyZXNwb25zZS5zdGF0dXMpICYmIG9wdGlvbnM/LmNoYXRDb21wbGV0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU2VydmVyICR7YXJncy5tb2RlbH0gZG9lcyBub3Qgc2VlbSB0byBzdXBwb3J0IGNoYXQgY29tcGxldGlvbi4gRXJyb3I6ICR7b3V0cHV0LmVycm9yfWApO1xuICAgICAgfVxuICAgICAgaWYgKG91dHB1dC5lcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iob3V0cHV0LmVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBTZXJ2ZXIgcmVzcG9uc2UgY29udGFpbnMgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICB9XG4gIGlmICghcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIik/LnN0YXJ0c1dpdGgoXCJ0ZXh0L2V2ZW50LXN0cmVhbVwiKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBTZXJ2ZXIgZG9lcyBub3Qgc3VwcG9ydCBldmVudCBzdHJlYW0gY29udGVudCB0eXBlLCBpdCByZXR1cm5lZCBgICsgcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIilcbiAgICApO1xuICB9XG4gIGlmICghcmVzcG9uc2UuYm9keSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICBsZXQgZXZlbnRzID0gW107XG4gIGNvbnN0IG9uRXZlbnQgPSAoZXZlbnQpID0+IHtcbiAgICBldmVudHMucHVzaChldmVudCk7XG4gIH07XG4gIGNvbnN0IG9uQ2h1bmsgPSBnZXRMaW5lcyhcbiAgICBnZXRNZXNzYWdlcyhcbiAgICAgICgpID0+IHtcbiAgICAgIH0sXG4gICAgICAoKSA9PiB7XG4gICAgICB9LFxuICAgICAgb25FdmVudFxuICAgIClcbiAgKTtcbiAgdHJ5IHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgIGlmIChkb25lKVxuICAgICAgICByZXR1cm47XG4gICAgICBvbkNodW5rKHZhbHVlKTtcbiAgICAgIGZvciAoY29uc3QgZXZlbnQgb2YgZXZlbnRzKSB7XG4gICAgICAgIGlmIChldmVudC5kYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBpZiAoZXZlbnQuZGF0YSA9PT0gXCJbRE9ORV1cIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcbiAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCIgJiYgZGF0YSAhPT0gbnVsbCAmJiBcImVycm9yXCIgaW4gZGF0YSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGRhdGEuZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB5aWVsZCBkYXRhO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBldmVudHMgPSBbXTtcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gIH1cbn1cblxuLy8gc3JjL2xpYi9JbmZlcmVuY2VPdXRwdXRFcnJvci50c1xudmFyIEluZmVyZW5jZU91dHB1dEVycm9yID0gY2xhc3MgZXh0ZW5kcyBUeXBlRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIoXG4gICAgICBgSW52YWxpZCBpbmZlcmVuY2Ugb3V0cHV0OiAke21lc3NhZ2V9LiBVc2UgdGhlICdyZXF1ZXN0JyBtZXRob2Qgd2l0aCB0aGUgc2FtZSBwYXJhbWV0ZXJzIHRvIGRvIGEgY3VzdG9tIGNhbGwgd2l0aCBubyB0eXBlIGNoZWNraW5nLmBcbiAgICApO1xuICAgIHRoaXMubmFtZSA9IFwiSW5mZXJlbmNlT3V0cHV0RXJyb3JcIjtcbiAgfVxufTtcblxuLy8gc3JjL3Rhc2tzL2F1ZGlvL2F1ZGlvQ2xhc3NpZmljYXRpb24udHNcbmFzeW5jIGZ1bmN0aW9uIGF1ZGlvQ2xhc3NpZmljYXRpb24oYXJncywgb3B0aW9ucykge1xuICBjb25zdCByZXMgPSBhd2FpdCByZXF1ZXN0KGFyZ3MsIHtcbiAgICAuLi5vcHRpb25zLFxuICAgIHRhc2tIaW50OiBcImF1ZGlvLWNsYXNzaWZpY2F0aW9uXCJcbiAgfSk7XG4gIGNvbnN0IGlzVmFsaWRPdXRwdXQgPSBBcnJheS5pc0FycmF5KHJlcykgJiYgcmVzLmV2ZXJ5KCh4KSA9PiB0eXBlb2YgeC5sYWJlbCA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgeC5zY29yZSA9PT0gXCJudW1iZXJcIik7XG4gIGlmICghaXNWYWxpZE91dHB1dCkge1xuICAgIHRocm93IG5ldyBJbmZlcmVuY2VPdXRwdXRFcnJvcihcIkV4cGVjdGVkIEFycmF5PHtsYWJlbDogc3RyaW5nLCBzY29yZTogbnVtYmVyfT5cIik7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy8gc3JjL3Rhc2tzL2F1ZGlvL2F1dG9tYXRpY1NwZWVjaFJlY29nbml0aW9uLnRzXG5hc3luYyBmdW5jdGlvbiBhdXRvbWF0aWNTcGVlY2hSZWNvZ25pdGlvbihhcmdzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IHJlcXVlc3QoYXJncywge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgdGFza0hpbnQ6IFwiYXV0b21hdGljLXNwZWVjaC1yZWNvZ25pdGlvblwiXG4gIH0pO1xuICBjb25zdCBpc1ZhbGlkT3V0cHV0ID0gdHlwZW9mIHJlcz8udGV4dCA9PT0gXCJzdHJpbmdcIjtcbiAgaWYgKCFpc1ZhbGlkT3V0cHV0KSB7XG4gICAgdGhyb3cgbmV3IEluZmVyZW5jZU91dHB1dEVycm9yKFwiRXhwZWN0ZWQge3RleHQ6IHN0cmluZ31cIik7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy8gc3JjL3Rhc2tzL2F1ZGlvL3RleHRUb1NwZWVjaC50c1xuYXN5bmMgZnVuY3Rpb24gdGV4dFRvU3BlZWNoKGFyZ3MsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVzID0gYXdhaXQgcmVxdWVzdChhcmdzLCB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICB0YXNrSGludDogXCJ0ZXh0LXRvLXNwZWVjaFwiXG4gIH0pO1xuICBjb25zdCBpc1ZhbGlkT3V0cHV0ID0gcmVzICYmIHJlcyBpbnN0YW5jZW9mIEJsb2I7XG4gIGlmICghaXNWYWxpZE91dHB1dCkge1xuICAgIHRocm93IG5ldyBJbmZlcmVuY2VPdXRwdXRFcnJvcihcIkV4cGVjdGVkIEJsb2JcIik7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy8gc3JjL3Rhc2tzL2F1ZGlvL2F1ZGlvVG9BdWRpby50c1xuYXN5bmMgZnVuY3Rpb24gYXVkaW9Ub0F1ZGlvKGFyZ3MsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVzID0gYXdhaXQgcmVxdWVzdChhcmdzLCB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICB0YXNrSGludDogXCJhdWRpby10by1hdWRpb1wiXG4gIH0pO1xuICBjb25zdCBpc1ZhbGlkT3V0cHV0ID0gQXJyYXkuaXNBcnJheShyZXMpICYmIHJlcy5ldmVyeShcbiAgICAoeCkgPT4gdHlwZW9mIHgubGFiZWwgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHguYmxvYiA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgeFtcImNvbnRlbnQtdHlwZVwiXSA9PT0gXCJzdHJpbmdcIlxuICApO1xuICBpZiAoIWlzVmFsaWRPdXRwdXQpIHtcbiAgICB0aHJvdyBuZXcgSW5mZXJlbmNlT3V0cHV0RXJyb3IoXCJFeHBlY3RlZCBBcnJheTx7bGFiZWw6IHN0cmluZywgYmxvYjogc3RyaW5nLCBjb250ZW50LXR5cGU6IHN0cmluZ30+XCIpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vIHNyYy90YXNrcy9jdi9pbWFnZUNsYXNzaWZpY2F0aW9uLnRzXG5hc3luYyBmdW5jdGlvbiBpbWFnZUNsYXNzaWZpY2F0aW9uKGFyZ3MsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVzID0gYXdhaXQgcmVxdWVzdChhcmdzLCB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICB0YXNrSGludDogXCJpbWFnZS1jbGFzc2lmaWNhdGlvblwiXG4gIH0pO1xuICBjb25zdCBpc1ZhbGlkT3V0cHV0ID0gQXJyYXkuaXNBcnJheShyZXMpICYmIHJlcy5ldmVyeSgoeCkgPT4gdHlwZW9mIHgubGFiZWwgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHguc2NvcmUgPT09IFwibnVtYmVyXCIpO1xuICBpZiAoIWlzVmFsaWRPdXRwdXQpIHtcbiAgICB0aHJvdyBuZXcgSW5mZXJlbmNlT3V0cHV0RXJyb3IoXCJFeHBlY3RlZCBBcnJheTx7bGFiZWw6IHN0cmluZywgc2NvcmU6IG51bWJlcn0+XCIpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vIHNyYy90YXNrcy9jdi9pbWFnZVNlZ21lbnRhdGlvbi50c1xuYXN5bmMgZnVuY3Rpb24gaW1hZ2VTZWdtZW50YXRpb24oYXJncywgb3B0aW9ucykge1xuICBjb25zdCByZXMgPSBhd2FpdCByZXF1ZXN0KGFyZ3MsIHtcbiAgICAuLi5vcHRpb25zLFxuICAgIHRhc2tIaW50OiBcImltYWdlLXNlZ21lbnRhdGlvblwiXG4gIH0pO1xuICBjb25zdCBpc1ZhbGlkT3V0cHV0ID0gQXJyYXkuaXNBcnJheShyZXMpICYmIHJlcy5ldmVyeSgoeCkgPT4gdHlwZW9mIHgubGFiZWwgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHgubWFzayA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgeC5zY29yZSA9PT0gXCJudW1iZXJcIik7XG4gIGlmICghaXNWYWxpZE91dHB1dCkge1xuICAgIHRocm93IG5ldyBJbmZlcmVuY2VPdXRwdXRFcnJvcihcIkV4cGVjdGVkIEFycmF5PHtsYWJlbDogc3RyaW5nLCBtYXNrOiBzdHJpbmcsIHNjb3JlOiBudW1iZXJ9PlwiKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vLyBzcmMvdGFza3MvY3YvaW1hZ2VUb1RleHQudHNcbmFzeW5jIGZ1bmN0aW9uIGltYWdlVG9UZXh0KGFyZ3MsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVzID0gKGF3YWl0IHJlcXVlc3QoYXJncywge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgdGFza0hpbnQ6IFwiaW1hZ2UtdG8tdGV4dFwiXG4gIH0pKT8uWzBdO1xuICBpZiAodHlwZW9mIHJlcz8uZ2VuZXJhdGVkX3RleHQgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgSW5mZXJlbmNlT3V0cHV0RXJyb3IoXCJFeHBlY3RlZCB7Z2VuZXJhdGVkX3RleHQ6IHN0cmluZ31cIik7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy8gc3JjL3Rhc2tzL2N2L29iamVjdERldGVjdGlvbi50c1xuYXN5bmMgZnVuY3Rpb24gb2JqZWN0RGV0ZWN0aW9uKGFyZ3MsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVzID0gYXdhaXQgcmVxdWVzdChhcmdzLCB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICB0YXNrSGludDogXCJvYmplY3QtZGV0ZWN0aW9uXCJcbiAgfSk7XG4gIGNvbnN0IGlzVmFsaWRPdXRwdXQgPSBBcnJheS5pc0FycmF5KHJlcykgJiYgcmVzLmV2ZXJ5KFxuICAgICh4KSA9PiB0eXBlb2YgeC5sYWJlbCA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgeC5zY29yZSA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgeC5ib3gueG1pbiA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgeC5ib3gueW1pbiA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgeC5ib3gueG1heCA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgeC5ib3gueW1heCA9PT0gXCJudW1iZXJcIlxuICApO1xuICBpZiAoIWlzVmFsaWRPdXRwdXQpIHtcbiAgICB0aHJvdyBuZXcgSW5mZXJlbmNlT3V0cHV0RXJyb3IoXG4gICAgICBcIkV4cGVjdGVkIEFycmF5PHtsYWJlbDpzdHJpbmc7IHNjb3JlOm51bWJlcjsgYm94Ont4bWluOm51bWJlcjsgeW1pbjpudW1iZXI7IHhtYXg6bnVtYmVyOyB5bWF4Om51bWJlcn19PlwiXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vLyBzcmMvdGFza3MvY3YvdGV4dFRvSW1hZ2UudHNcbmFzeW5jIGZ1bmN0aW9uIHRleHRUb0ltYWdlKGFyZ3MsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVzID0gYXdhaXQgcmVxdWVzdChhcmdzLCB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICB0YXNrSGludDogXCJ0ZXh0LXRvLWltYWdlXCJcbiAgfSk7XG4gIGNvbnN0IGlzVmFsaWRPdXRwdXQgPSByZXMgJiYgcmVzIGluc3RhbmNlb2YgQmxvYjtcbiAgaWYgKCFpc1ZhbGlkT3V0cHV0KSB7XG4gICAgdGhyb3cgbmV3IEluZmVyZW5jZU91dHB1dEVycm9yKFwiRXhwZWN0ZWQgQmxvYlwiKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vLyBzcmMvdXRpbHMvYmFzZTY0RnJvbUJ5dGVzLnRzXG5mdW5jdGlvbiBiYXNlNjRGcm9tQnl0ZXMoYXJyKSB7XG4gIGlmIChnbG9iYWxUaGlzLkJ1ZmZlcikge1xuICAgIHJldHVybiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGFycikudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgYmluID0gW107XG4gICAgYXJyLmZvckVhY2goKGJ5dGUpID0+IHtcbiAgICAgIGJpbi5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZSkpO1xuICAgIH0pO1xuICAgIHJldHVybiBnbG9iYWxUaGlzLmJ0b2EoYmluLmpvaW4oXCJcIikpO1xuICB9XG59XG5cbi8vIHNyYy90YXNrcy9jdi9pbWFnZVRvSW1hZ2UudHNcbmFzeW5jIGZ1bmN0aW9uIGltYWdlVG9JbWFnZShhcmdzLCBvcHRpb25zKSB7XG4gIGxldCByZXFBcmdzO1xuICBpZiAoIWFyZ3MucGFyYW1ldGVycykge1xuICAgIHJlcUFyZ3MgPSB7XG4gICAgICBhY2Nlc3NUb2tlbjogYXJncy5hY2Nlc3NUb2tlbixcbiAgICAgIG1vZGVsOiBhcmdzLm1vZGVsLFxuICAgICAgZGF0YTogYXJncy5pbnB1dHNcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJlcUFyZ3MgPSB7XG4gICAgICAuLi5hcmdzLFxuICAgICAgaW5wdXRzOiBiYXNlNjRGcm9tQnl0ZXMoXG4gICAgICAgIG5ldyBVaW50OEFycmF5KGFyZ3MuaW5wdXRzIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgPyBhcmdzLmlucHV0cyA6IGF3YWl0IGFyZ3MuaW5wdXRzLmFycmF5QnVmZmVyKCkpXG4gICAgICApXG4gICAgfTtcbiAgfVxuICBjb25zdCByZXMgPSBhd2FpdCByZXF1ZXN0KHJlcUFyZ3MsIHtcbiAgICAuLi5vcHRpb25zLFxuICAgIHRhc2tIaW50OiBcImltYWdlLXRvLWltYWdlXCJcbiAgfSk7XG4gIGNvbnN0IGlzVmFsaWRPdXRwdXQgPSByZXMgJiYgcmVzIGluc3RhbmNlb2YgQmxvYjtcbiAgaWYgKCFpc1ZhbGlkT3V0cHV0KSB7XG4gICAgdGhyb3cgbmV3IEluZmVyZW5jZU91dHB1dEVycm9yKFwiRXhwZWN0ZWQgQmxvYlwiKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vLyBzcmMvdGFza3MvY3YvemVyb1Nob3RJbWFnZUNsYXNzaWZpY2F0aW9uLnRzXG5hc3luYyBmdW5jdGlvbiB6ZXJvU2hvdEltYWdlQ2xhc3NpZmljYXRpb24oYXJncywgb3B0aW9ucykge1xuICBjb25zdCByZXFBcmdzID0ge1xuICAgIC4uLmFyZ3MsXG4gICAgaW5wdXRzOiB7XG4gICAgICBpbWFnZTogYmFzZTY0RnJvbUJ5dGVzKFxuICAgICAgICBuZXcgVWludDhBcnJheShcbiAgICAgICAgICBhcmdzLmlucHV0cy5pbWFnZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID8gYXJncy5pbnB1dHMuaW1hZ2UgOiBhd2FpdCBhcmdzLmlucHV0cy5pbWFnZS5hcnJheUJ1ZmZlcigpXG4gICAgICAgIClcbiAgICAgIClcbiAgICB9XG4gIH07XG4gIGNvbnN0IHJlcyA9IGF3YWl0IHJlcXVlc3QocmVxQXJncywge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgdGFza0hpbnQ6IFwiemVyby1zaG90LWltYWdlLWNsYXNzaWZpY2F0aW9uXCJcbiAgfSk7XG4gIGNvbnN0IGlzVmFsaWRPdXRwdXQgPSBBcnJheS5pc0FycmF5KHJlcykgJiYgcmVzLmV2ZXJ5KCh4KSA9PiB0eXBlb2YgeC5sYWJlbCA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgeC5zY29yZSA9PT0gXCJudW1iZXJcIik7XG4gIGlmICghaXNWYWxpZE91dHB1dCkge1xuICAgIHRocm93IG5ldyBJbmZlcmVuY2VPdXRwdXRFcnJvcihcIkV4cGVjdGVkIEFycmF5PHtsYWJlbDogc3RyaW5nLCBzY29yZTogbnVtYmVyfT5cIik7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy8gc3JjL3Rhc2tzL25scC9mZWF0dXJlRXh0cmFjdGlvbi50c1xuYXN5bmMgZnVuY3Rpb24gZmVhdHVyZUV4dHJhY3Rpb24oYXJncywgb3B0aW9ucykge1xuICBjb25zdCBkZWZhdWx0VGFzayA9IGFyZ3MubW9kZWwgPyBhd2FpdCBnZXREZWZhdWx0VGFzayhhcmdzLm1vZGVsLCBhcmdzLmFjY2Vzc1Rva2VuLCBvcHRpb25zKSA6IHZvaWQgMDtcbiAgY29uc3QgcmVzID0gYXdhaXQgcmVxdWVzdChhcmdzLCB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICB0YXNrSGludDogXCJmZWF0dXJlLWV4dHJhY3Rpb25cIixcbiAgICAuLi5kZWZhdWx0VGFzayA9PT0gXCJzZW50ZW5jZS1zaW1pbGFyaXR5XCIgJiYgeyBmb3JjZVRhc2s6IFwiZmVhdHVyZS1leHRyYWN0aW9uXCIgfVxuICB9KTtcbiAgbGV0IGlzVmFsaWRPdXRwdXQgPSB0cnVlO1xuICBjb25zdCBpc051bUFycmF5UmVjID0gKGFyciwgbWF4RGVwdGgsIGN1ckRlcHRoID0gMCkgPT4ge1xuICAgIGlmIChjdXJEZXB0aCA+IG1heERlcHRoKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChhcnIuZXZlcnkoKHgpID0+IEFycmF5LmlzQXJyYXkoeCkpKSB7XG4gICAgICByZXR1cm4gYXJyLmV2ZXJ5KCh4KSA9PiBpc051bUFycmF5UmVjKHgsIG1heERlcHRoLCBjdXJEZXB0aCArIDEpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFyci5ldmVyeSgoeCkgPT4gdHlwZW9mIHggPT09IFwibnVtYmVyXCIpO1xuICAgIH1cbiAgfTtcbiAgaXNWYWxpZE91dHB1dCA9IEFycmF5LmlzQXJyYXkocmVzKSAmJiBpc051bUFycmF5UmVjKHJlcywgMywgMCk7XG4gIGlmICghaXNWYWxpZE91dHB1dCkge1xuICAgIHRocm93IG5ldyBJbmZlcmVuY2VPdXRwdXRFcnJvcihcIkV4cGVjdGVkIEFycmF5PG51bWJlcltdW11bXSB8IG51bWJlcltdW10gfCBudW1iZXJbXSB8IG51bWJlcj5cIik7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy8gc3JjL3Rhc2tzL25scC9maWxsTWFzay50c1xuYXN5bmMgZnVuY3Rpb24gZmlsbE1hc2soYXJncywgb3B0aW9ucykge1xuICBjb25zdCByZXMgPSBhd2FpdCByZXF1ZXN0KGFyZ3MsIHtcbiAgICAuLi5vcHRpb25zLFxuICAgIHRhc2tIaW50OiBcImZpbGwtbWFza1wiXG4gIH0pO1xuICBjb25zdCBpc1ZhbGlkT3V0cHV0ID0gQXJyYXkuaXNBcnJheShyZXMpICYmIHJlcy5ldmVyeShcbiAgICAoeCkgPT4gdHlwZW9mIHguc2NvcmUgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHguc2VxdWVuY2UgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHgudG9rZW4gPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHgudG9rZW5fc3RyID09PSBcInN0cmluZ1wiXG4gICk7XG4gIGlmICghaXNWYWxpZE91dHB1dCkge1xuICAgIHRocm93IG5ldyBJbmZlcmVuY2VPdXRwdXRFcnJvcihcbiAgICAgIFwiRXhwZWN0ZWQgQXJyYXk8e3Njb3JlOiBudW1iZXIsIHNlcXVlbmNlOiBzdHJpbmcsIHRva2VuOiBudW1iZXIsIHRva2VuX3N0cjogc3RyaW5nfT5cIlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy8gc3JjL3Rhc2tzL25scC9xdWVzdGlvbkFuc3dlcmluZy50c1xuYXN5bmMgZnVuY3Rpb24gcXVlc3Rpb25BbnN3ZXJpbmcoYXJncywgb3B0aW9ucykge1xuICBjb25zdCByZXMgPSBhd2FpdCByZXF1ZXN0KGFyZ3MsIHtcbiAgICAuLi5vcHRpb25zLFxuICAgIHRhc2tIaW50OiBcInF1ZXN0aW9uLWFuc3dlcmluZ1wiXG4gIH0pO1xuICBjb25zdCBpc1ZhbGlkT3V0cHV0ID0gdHlwZW9mIHJlcyA9PT0gXCJvYmplY3RcIiAmJiAhIXJlcyAmJiB0eXBlb2YgcmVzLmFuc3dlciA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgcmVzLmVuZCA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgcmVzLnNjb3JlID09PSBcIm51bWJlclwiICYmIHR5cGVvZiByZXMuc3RhcnQgPT09IFwibnVtYmVyXCI7XG4gIGlmICghaXNWYWxpZE91dHB1dCkge1xuICAgIHRocm93IG5ldyBJbmZlcmVuY2VPdXRwdXRFcnJvcihcIkV4cGVjdGVkIHthbnN3ZXI6IHN0cmluZywgZW5kOiBudW1iZXIsIHNjb3JlOiBudW1iZXIsIHN0YXJ0OiBudW1iZXJ9XCIpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vIHNyYy90YXNrcy9ubHAvc2VudGVuY2VTaW1pbGFyaXR5LnRzXG5hc3luYyBmdW5jdGlvbiBzZW50ZW5jZVNpbWlsYXJpdHkoYXJncywgb3B0aW9ucykge1xuICBjb25zdCBkZWZhdWx0VGFzayA9IGFyZ3MubW9kZWwgPyBhd2FpdCBnZXREZWZhdWx0VGFzayhhcmdzLm1vZGVsLCBhcmdzLmFjY2Vzc1Rva2VuLCBvcHRpb25zKSA6IHZvaWQgMDtcbiAgY29uc3QgcmVzID0gYXdhaXQgcmVxdWVzdChhcmdzLCB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICB0YXNrSGludDogXCJzZW50ZW5jZS1zaW1pbGFyaXR5XCIsXG4gICAgLi4uZGVmYXVsdFRhc2sgPT09IFwiZmVhdHVyZS1leHRyYWN0aW9uXCIgJiYgeyBmb3JjZVRhc2s6IFwic2VudGVuY2Utc2ltaWxhcml0eVwiIH1cbiAgfSk7XG4gIGNvbnN0IGlzVmFsaWRPdXRwdXQgPSBBcnJheS5pc0FycmF5KHJlcykgJiYgcmVzLmV2ZXJ5KCh4KSA9PiB0eXBlb2YgeCA9PT0gXCJudW1iZXJcIik7XG4gIGlmICghaXNWYWxpZE91dHB1dCkge1xuICAgIHRocm93IG5ldyBJbmZlcmVuY2VPdXRwdXRFcnJvcihcIkV4cGVjdGVkIG51bWJlcltdXCIpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vIHNyYy90YXNrcy9ubHAvc3VtbWFyaXphdGlvbi50c1xuYXN5bmMgZnVuY3Rpb24gc3VtbWFyaXphdGlvbihhcmdzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IHJlcXVlc3QoYXJncywge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgdGFza0hpbnQ6IFwic3VtbWFyaXphdGlvblwiXG4gIH0pO1xuICBjb25zdCBpc1ZhbGlkT3V0cHV0ID0gQXJyYXkuaXNBcnJheShyZXMpICYmIHJlcy5ldmVyeSgoeCkgPT4gdHlwZW9mIHg/LnN1bW1hcnlfdGV4dCA9PT0gXCJzdHJpbmdcIik7XG4gIGlmICghaXNWYWxpZE91dHB1dCkge1xuICAgIHRocm93IG5ldyBJbmZlcmVuY2VPdXRwdXRFcnJvcihcIkV4cGVjdGVkIEFycmF5PHtzdW1tYXJ5X3RleHQ6IHN0cmluZ30+XCIpO1xuICB9XG4gIHJldHVybiByZXM/LlswXTtcbn1cblxuLy8gc3JjL3Rhc2tzL25scC90YWJsZVF1ZXN0aW9uQW5zd2VyaW5nLnRzXG5hc3luYyBmdW5jdGlvbiB0YWJsZVF1ZXN0aW9uQW5zd2VyaW5nKGFyZ3MsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVzID0gYXdhaXQgcmVxdWVzdChhcmdzLCB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICB0YXNrSGludDogXCJ0YWJsZS1xdWVzdGlvbi1hbnN3ZXJpbmdcIlxuICB9KTtcbiAgY29uc3QgaXNWYWxpZE91dHB1dCA9IHR5cGVvZiByZXM/LmFnZ3JlZ2F0b3IgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHJlcy5hbnN3ZXIgPT09IFwic3RyaW5nXCIgJiYgQXJyYXkuaXNBcnJheShyZXMuY2VsbHMpICYmIHJlcy5jZWxscy5ldmVyeSgoeCkgPT4gdHlwZW9mIHggPT09IFwic3RyaW5nXCIpICYmIEFycmF5LmlzQXJyYXkocmVzLmNvb3JkaW5hdGVzKSAmJiByZXMuY29vcmRpbmF0ZXMuZXZlcnkoKGNvb3JkKSA9PiBBcnJheS5pc0FycmF5KGNvb3JkKSAmJiBjb29yZC5ldmVyeSgoeCkgPT4gdHlwZW9mIHggPT09IFwibnVtYmVyXCIpKTtcbiAgaWYgKCFpc1ZhbGlkT3V0cHV0KSB7XG4gICAgdGhyb3cgbmV3IEluZmVyZW5jZU91dHB1dEVycm9yKFxuICAgICAgXCJFeHBlY3RlZCB7YWdncmVnYXRvcjogc3RyaW5nLCBhbnN3ZXI6IHN0cmluZywgY2VsbHM6IHN0cmluZ1tdLCBjb29yZGluYXRlczogbnVtYmVyW11bXX1cIlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy8gc3JjL3Rhc2tzL25scC90ZXh0Q2xhc3NpZmljYXRpb24udHNcbmFzeW5jIGZ1bmN0aW9uIHRleHRDbGFzc2lmaWNhdGlvbihhcmdzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJlcyA9IChhd2FpdCByZXF1ZXN0KGFyZ3MsIHtcbiAgICAuLi5vcHRpb25zLFxuICAgIHRhc2tIaW50OiBcInRleHQtY2xhc3NpZmljYXRpb25cIlxuICB9KSk/LlswXTtcbiAgY29uc3QgaXNWYWxpZE91dHB1dCA9IEFycmF5LmlzQXJyYXkocmVzKSAmJiByZXMuZXZlcnkoKHgpID0+IHR5cGVvZiB4Py5sYWJlbCA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgeC5zY29yZSA9PT0gXCJudW1iZXJcIik7XG4gIGlmICghaXNWYWxpZE91dHB1dCkge1xuICAgIHRocm93IG5ldyBJbmZlcmVuY2VPdXRwdXRFcnJvcihcIkV4cGVjdGVkIEFycmF5PHtsYWJlbDogc3RyaW5nLCBzY29yZTogbnVtYmVyfT5cIik7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy8gc3JjL3V0aWxzL3RvQXJyYXkudHNcbmZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIHJldHVybiBbb2JqXTtcbn1cblxuLy8gc3JjL3Rhc2tzL25scC90ZXh0R2VuZXJhdGlvbi50c1xuYXN5bmMgZnVuY3Rpb24gdGV4dEdlbmVyYXRpb24oYXJncywgb3B0aW9ucykge1xuICBjb25zdCByZXMgPSB0b0FycmF5KFxuICAgIGF3YWl0IHJlcXVlc3QoYXJncywge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHRhc2tIaW50OiBcInRleHQtZ2VuZXJhdGlvblwiXG4gICAgfSlcbiAgKTtcbiAgY29uc3QgaXNWYWxpZE91dHB1dCA9IEFycmF5LmlzQXJyYXkocmVzKSAmJiByZXMuZXZlcnkoKHgpID0+IHR5cGVvZiB4Py5nZW5lcmF0ZWRfdGV4dCA9PT0gXCJzdHJpbmdcIik7XG4gIGlmICghaXNWYWxpZE91dHB1dCkge1xuICAgIHRocm93IG5ldyBJbmZlcmVuY2VPdXRwdXRFcnJvcihcIkV4cGVjdGVkIEFycmF5PHtnZW5lcmF0ZWRfdGV4dDogc3RyaW5nfT5cIik7XG4gIH1cbiAgcmV0dXJuIHJlcz8uWzBdO1xufVxuXG4vLyBzcmMvdGFza3MvbmxwL3RleHRHZW5lcmF0aW9uU3RyZWFtLnRzXG5hc3luYyBmdW5jdGlvbiogdGV4dEdlbmVyYXRpb25TdHJlYW0oYXJncywgb3B0aW9ucykge1xuICB5aWVsZCogc3RyZWFtaW5nUmVxdWVzdChhcmdzLCB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICB0YXNrSGludDogXCJ0ZXh0LWdlbmVyYXRpb25cIlxuICB9KTtcbn1cblxuLy8gc3JjL3Rhc2tzL25scC90b2tlbkNsYXNzaWZpY2F0aW9uLnRzXG5hc3luYyBmdW5jdGlvbiB0b2tlbkNsYXNzaWZpY2F0aW9uKGFyZ3MsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVzID0gdG9BcnJheShcbiAgICBhd2FpdCByZXF1ZXN0KGFyZ3MsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICB0YXNrSGludDogXCJ0b2tlbi1jbGFzc2lmaWNhdGlvblwiXG4gICAgfSlcbiAgKTtcbiAgY29uc3QgaXNWYWxpZE91dHB1dCA9IEFycmF5LmlzQXJyYXkocmVzKSAmJiByZXMuZXZlcnkoXG4gICAgKHgpID0+IHR5cGVvZiB4LmVuZCA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgeC5lbnRpdHlfZ3JvdXAgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHguc2NvcmUgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHguc3RhcnQgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHgud29yZCA9PT0gXCJzdHJpbmdcIlxuICApO1xuICBpZiAoIWlzVmFsaWRPdXRwdXQpIHtcbiAgICB0aHJvdyBuZXcgSW5mZXJlbmNlT3V0cHV0RXJyb3IoXG4gICAgICBcIkV4cGVjdGVkIEFycmF5PHtlbmQ6IG51bWJlciwgZW50aXR5X2dyb3VwOiBzdHJpbmcsIHNjb3JlOiBudW1iZXIsIHN0YXJ0OiBudW1iZXIsIHdvcmQ6IHN0cmluZ30+XCJcbiAgICApO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vIHNyYy90YXNrcy9ubHAvdHJhbnNsYXRpb24udHNcbmFzeW5jIGZ1bmN0aW9uIHRyYW5zbGF0aW9uKGFyZ3MsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVzID0gYXdhaXQgcmVxdWVzdChhcmdzLCB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICB0YXNrSGludDogXCJ0cmFuc2xhdGlvblwiXG4gIH0pO1xuICBjb25zdCBpc1ZhbGlkT3V0cHV0ID0gQXJyYXkuaXNBcnJheShyZXMpICYmIHJlcy5ldmVyeSgoeCkgPT4gdHlwZW9mIHg/LnRyYW5zbGF0aW9uX3RleHQgPT09IFwic3RyaW5nXCIpO1xuICBpZiAoIWlzVmFsaWRPdXRwdXQpIHtcbiAgICB0aHJvdyBuZXcgSW5mZXJlbmNlT3V0cHV0RXJyb3IoXCJFeHBlY3RlZCB0eXBlIEFycmF5PHt0cmFuc2xhdGlvbl90ZXh0OiBzdHJpbmd9PlwiKTtcbiAgfVxuICByZXR1cm4gcmVzPy5sZW5ndGggPT09IDEgPyByZXM/LlswXSA6IHJlcztcbn1cblxuLy8gc3JjL3Rhc2tzL25scC96ZXJvU2hvdENsYXNzaWZpY2F0aW9uLnRzXG5hc3luYyBmdW5jdGlvbiB6ZXJvU2hvdENsYXNzaWZpY2F0aW9uKGFyZ3MsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVzID0gdG9BcnJheShcbiAgICBhd2FpdCByZXF1ZXN0KGFyZ3MsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICB0YXNrSGludDogXCJ6ZXJvLXNob3QtY2xhc3NpZmljYXRpb25cIlxuICAgIH0pXG4gICk7XG4gIGNvbnN0IGlzVmFsaWRPdXRwdXQgPSBBcnJheS5pc0FycmF5KHJlcykgJiYgcmVzLmV2ZXJ5KFxuICAgICh4KSA9PiBBcnJheS5pc0FycmF5KHgubGFiZWxzKSAmJiB4LmxhYmVscy5ldmVyeSgoX2xhYmVsKSA9PiB0eXBlb2YgX2xhYmVsID09PSBcInN0cmluZ1wiKSAmJiBBcnJheS5pc0FycmF5KHguc2NvcmVzKSAmJiB4LnNjb3Jlcy5ldmVyeSgoX3Njb3JlKSA9PiB0eXBlb2YgX3Njb3JlID09PSBcIm51bWJlclwiKSAmJiB0eXBlb2YgeC5zZXF1ZW5jZSA9PT0gXCJzdHJpbmdcIlxuICApO1xuICBpZiAoIWlzVmFsaWRPdXRwdXQpIHtcbiAgICB0aHJvdyBuZXcgSW5mZXJlbmNlT3V0cHV0RXJyb3IoXCJFeHBlY3RlZCBBcnJheTx7bGFiZWxzOiBzdHJpbmdbXSwgc2NvcmVzOiBudW1iZXJbXSwgc2VxdWVuY2U6IHN0cmluZ30+XCIpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vIHNyYy90YXNrcy9ubHAvY2hhdENvbXBsZXRpb24udHNcbmFzeW5jIGZ1bmN0aW9uIGNoYXRDb21wbGV0aW9uKGFyZ3MsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVzID0gYXdhaXQgcmVxdWVzdChhcmdzLCB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICB0YXNrSGludDogXCJ0ZXh0LWdlbmVyYXRpb25cIixcbiAgICBjaGF0Q29tcGxldGlvbjogdHJ1ZVxuICB9KTtcbiAgY29uc3QgaXNWYWxpZE91dHB1dCA9IHR5cGVvZiByZXMgPT09IFwib2JqZWN0XCIgJiYgQXJyYXkuaXNBcnJheShyZXM/LmNob2ljZXMpICYmIHR5cGVvZiByZXM/LmNyZWF0ZWQgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHJlcz8uaWQgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHJlcz8ubW9kZWwgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHJlcz8uc3lzdGVtX2ZpbmdlcnByaW50ID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiByZXM/LnVzYWdlID09PSBcIm9iamVjdFwiO1xuICBpZiAoIWlzVmFsaWRPdXRwdXQpIHtcbiAgICB0aHJvdyBuZXcgSW5mZXJlbmNlT3V0cHV0RXJyb3IoXCJFeHBlY3RlZCBDaGF0Q29tcGxldGlvbk91dHB1dFwiKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vLyBzcmMvdGFza3MvbmxwL2NoYXRDb21wbGV0aW9uU3RyZWFtLnRzXG5hc3luYyBmdW5jdGlvbiogY2hhdENvbXBsZXRpb25TdHJlYW0oYXJncywgb3B0aW9ucykge1xuICB5aWVsZCogc3RyZWFtaW5nUmVxdWVzdChhcmdzLCB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICB0YXNrSGludDogXCJ0ZXh0LWdlbmVyYXRpb25cIixcbiAgICBjaGF0Q29tcGxldGlvbjogdHJ1ZVxuICB9KTtcbn1cblxuLy8gc3JjL3Rhc2tzL211bHRpbW9kYWwvZG9jdW1lbnRRdWVzdGlvbkFuc3dlcmluZy50c1xuYXN5bmMgZnVuY3Rpb24gZG9jdW1lbnRRdWVzdGlvbkFuc3dlcmluZyhhcmdzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJlcUFyZ3MgPSB7XG4gICAgLi4uYXJncyxcbiAgICBpbnB1dHM6IHtcbiAgICAgIHF1ZXN0aW9uOiBhcmdzLmlucHV0cy5xdWVzdGlvbixcbiAgICAgIC8vIGNvbnZlcnQgQmxvYiBvciBBcnJheUJ1ZmZlciB0byBiYXNlNjRcbiAgICAgIGltYWdlOiBiYXNlNjRGcm9tQnl0ZXMoXG4gICAgICAgIG5ldyBVaW50OEFycmF5KFxuICAgICAgICAgIGFyZ3MuaW5wdXRzLmltYWdlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgPyBhcmdzLmlucHV0cy5pbWFnZSA6IGF3YWl0IGFyZ3MuaW5wdXRzLmltYWdlLmFycmF5QnVmZmVyKClcbiAgICAgICAgKVxuICAgICAgKVxuICAgIH1cbiAgfTtcbiAgY29uc3QgcmVzID0gdG9BcnJheShcbiAgICBhd2FpdCByZXF1ZXN0KHJlcUFyZ3MsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICB0YXNrSGludDogXCJkb2N1bWVudC1xdWVzdGlvbi1hbnN3ZXJpbmdcIlxuICAgIH0pXG4gICk/LlswXTtcbiAgY29uc3QgaXNWYWxpZE91dHB1dCA9IHR5cGVvZiByZXM/LmFuc3dlciA9PT0gXCJzdHJpbmdcIiAmJiAodHlwZW9mIHJlcy5lbmQgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHJlcy5lbmQgPT09IFwidW5kZWZpbmVkXCIpICYmICh0eXBlb2YgcmVzLnNjb3JlID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiByZXMuc2NvcmUgPT09IFwidW5kZWZpbmVkXCIpICYmICh0eXBlb2YgcmVzLnN0YXJ0ID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiByZXMuc3RhcnQgPT09IFwidW5kZWZpbmVkXCIpO1xuICBpZiAoIWlzVmFsaWRPdXRwdXQpIHtcbiAgICB0aHJvdyBuZXcgSW5mZXJlbmNlT3V0cHV0RXJyb3IoXCJFeHBlY3RlZCBBcnJheTx7YW5zd2VyOiBzdHJpbmcsIGVuZD86IG51bWJlciwgc2NvcmU/OiBudW1iZXIsIHN0YXJ0PzogbnVtYmVyfT5cIik7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy8gc3JjL3Rhc2tzL211bHRpbW9kYWwvdmlzdWFsUXVlc3Rpb25BbnN3ZXJpbmcudHNcbmFzeW5jIGZ1bmN0aW9uIHZpc3VhbFF1ZXN0aW9uQW5zd2VyaW5nKGFyZ3MsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVxQXJncyA9IHtcbiAgICAuLi5hcmdzLFxuICAgIGlucHV0czoge1xuICAgICAgcXVlc3Rpb246IGFyZ3MuaW5wdXRzLnF1ZXN0aW9uLFxuICAgICAgLy8gY29udmVydCBCbG9iIG9yIEFycmF5QnVmZmVyIHRvIGJhc2U2NFxuICAgICAgaW1hZ2U6IGJhc2U2NEZyb21CeXRlcyhcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoXG4gICAgICAgICAgYXJncy5pbnB1dHMuaW1hZ2UgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciA/IGFyZ3MuaW5wdXRzLmltYWdlIDogYXdhaXQgYXJncy5pbnB1dHMuaW1hZ2UuYXJyYXlCdWZmZXIoKVxuICAgICAgICApXG4gICAgICApXG4gICAgfVxuICB9O1xuICBjb25zdCByZXMgPSAoYXdhaXQgcmVxdWVzdChyZXFBcmdzLCB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICB0YXNrSGludDogXCJ2aXN1YWwtcXVlc3Rpb24tYW5zd2VyaW5nXCJcbiAgfSkpPy5bMF07XG4gIGNvbnN0IGlzVmFsaWRPdXRwdXQgPSB0eXBlb2YgcmVzPy5hbnN3ZXIgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHJlcy5zY29yZSA9PT0gXCJudW1iZXJcIjtcbiAgaWYgKCFpc1ZhbGlkT3V0cHV0KSB7XG4gICAgdGhyb3cgbmV3IEluZmVyZW5jZU91dHB1dEVycm9yKFwiRXhwZWN0ZWQgQXJyYXk8e2Fuc3dlcjogc3RyaW5nLCBzY29yZTogbnVtYmVyfT5cIik7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy8gc3JjL3Rhc2tzL3RhYnVsYXIvdGFidWxhclJlZ3Jlc3Npb24udHNcbmFzeW5jIGZ1bmN0aW9uIHRhYnVsYXJSZWdyZXNzaW9uKGFyZ3MsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVzID0gYXdhaXQgcmVxdWVzdChhcmdzLCB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICB0YXNrSGludDogXCJ0YWJ1bGFyLXJlZ3Jlc3Npb25cIlxuICB9KTtcbiAgY29uc3QgaXNWYWxpZE91dHB1dCA9IEFycmF5LmlzQXJyYXkocmVzKSAmJiByZXMuZXZlcnkoKHgpID0+IHR5cGVvZiB4ID09PSBcIm51bWJlclwiKTtcbiAgaWYgKCFpc1ZhbGlkT3V0cHV0KSB7XG4gICAgdGhyb3cgbmV3IEluZmVyZW5jZU91dHB1dEVycm9yKFwiRXhwZWN0ZWQgbnVtYmVyW11cIik7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy8gc3JjL3Rhc2tzL3RhYnVsYXIvdGFidWxhckNsYXNzaWZpY2F0aW9uLnRzXG5hc3luYyBmdW5jdGlvbiB0YWJ1bGFyQ2xhc3NpZmljYXRpb24oYXJncywgb3B0aW9ucykge1xuICBjb25zdCByZXMgPSBhd2FpdCByZXF1ZXN0KGFyZ3MsIHtcbiAgICAuLi5vcHRpb25zLFxuICAgIHRhc2tIaW50OiBcInRhYnVsYXItY2xhc3NpZmljYXRpb25cIlxuICB9KTtcbiAgY29uc3QgaXNWYWxpZE91dHB1dCA9IEFycmF5LmlzQXJyYXkocmVzKSAmJiByZXMuZXZlcnkoKHgpID0+IHR5cGVvZiB4ID09PSBcIm51bWJlclwiKTtcbiAgaWYgKCFpc1ZhbGlkT3V0cHV0KSB7XG4gICAgdGhyb3cgbmV3IEluZmVyZW5jZU91dHB1dEVycm9yKFwiRXhwZWN0ZWQgbnVtYmVyW11cIik7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy8gc3JjL0hmSW5mZXJlbmNlLnRzXG52YXIgSGZJbmZlcmVuY2UgPSBjbGFzcyB7XG4gIGFjY2Vzc1Rva2VuO1xuICBkZWZhdWx0T3B0aW9ucztcbiAgY29uc3RydWN0b3IoYWNjZXNzVG9rZW4gPSBcIlwiLCBkZWZhdWx0T3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5hY2Nlc3NUb2tlbiA9IGFjY2Vzc1Rva2VuO1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbiAgICBmb3IgKGNvbnN0IFtuYW1lLCBmbl0gb2YgT2JqZWN0LmVudHJpZXModGFza3NfZXhwb3J0cykpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogKHBhcmFtcywgb3B0aW9ucykgPT4gKFxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgZm4oeyAuLi5wYXJhbXMsIGFjY2Vzc1Rva2VuIH0sIHsgLi4uZGVmYXVsdE9wdGlvbnMsIC4uLm9wdGlvbnMgfSlcbiAgICAgICAgKVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGNvcHkgb2YgSGZJbmZlcmVuY2UgdGllZCB0byBhIHNwZWNpZmllZCBlbmRwb2ludC5cbiAgICovXG4gIGVuZHBvaW50KGVuZHBvaW50VXJsKSB7XG4gICAgcmV0dXJuIG5ldyBIZkluZmVyZW5jZUVuZHBvaW50KGVuZHBvaW50VXJsLCB0aGlzLmFjY2Vzc1Rva2VuLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcbiAgfVxufTtcbnZhciBIZkluZmVyZW5jZUVuZHBvaW50ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihlbmRwb2ludFVybCwgYWNjZXNzVG9rZW4gPSBcIlwiLCBkZWZhdWx0T3B0aW9ucyA9IHt9KSB7XG4gICAgYWNjZXNzVG9rZW47XG4gICAgZGVmYXVsdE9wdGlvbnM7XG4gICAgZm9yIChjb25zdCBbbmFtZSwgZm5dIG9mIE9iamVjdC5lbnRyaWVzKHRhc2tzX2V4cG9ydHMpKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IChwYXJhbXMsIG9wdGlvbnMpID0+IChcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgIGZuKHsgLi4ucGFyYW1zLCBhY2Nlc3NUb2tlbiwgZW5kcG9pbnRVcmwgfSwgeyAuLi5kZWZhdWx0T3B0aW9ucywgLi4ub3B0aW9ucyB9KVxuICAgICAgICApXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn07XG5leHBvcnQge1xuICBIZkluZmVyZW5jZSxcbiAgSGZJbmZlcmVuY2VFbmRwb2ludCxcbiAgSW5mZXJlbmNlT3V0cHV0RXJyb3IsXG4gIGF1ZGlvQ2xhc3NpZmljYXRpb24sXG4gIGF1ZGlvVG9BdWRpbyxcbiAgYXV0b21hdGljU3BlZWNoUmVjb2duaXRpb24sXG4gIGNoYXRDb21wbGV0aW9uLFxuICBjaGF0Q29tcGxldGlvblN0cmVhbSxcbiAgZG9jdW1lbnRRdWVzdGlvbkFuc3dlcmluZyxcbiAgZmVhdHVyZUV4dHJhY3Rpb24sXG4gIGZpbGxNYXNrLFxuICBpbWFnZUNsYXNzaWZpY2F0aW9uLFxuICBpbWFnZVNlZ21lbnRhdGlvbixcbiAgaW1hZ2VUb0ltYWdlLFxuICBpbWFnZVRvVGV4dCxcbiAgb2JqZWN0RGV0ZWN0aW9uLFxuICBxdWVzdGlvbkFuc3dlcmluZyxcbiAgcmVxdWVzdCxcbiAgc2VudGVuY2VTaW1pbGFyaXR5LFxuICBzdHJlYW1pbmdSZXF1ZXN0LFxuICBzdW1tYXJpemF0aW9uLFxuICB0YWJsZVF1ZXN0aW9uQW5zd2VyaW5nLFxuICB0YWJ1bGFyQ2xhc3NpZmljYXRpb24sXG4gIHRhYnVsYXJSZWdyZXNzaW9uLFxuICB0ZXh0Q2xhc3NpZmljYXRpb24sXG4gIHRleHRHZW5lcmF0aW9uLFxuICB0ZXh0R2VuZXJhdGlvblN0cmVhbSxcbiAgdGV4dFRvSW1hZ2UsXG4gIHRleHRUb1NwZWVjaCxcbiAgdG9rZW5DbGFzc2lmaWNhdGlvbixcbiAgdHJhbnNsYXRpb24sXG4gIHZpc3VhbFF1ZXN0aW9uQW5zd2VyaW5nLFxuICB6ZXJvU2hvdENsYXNzaWZpY2F0aW9uLFxuICB6ZXJvU2hvdEltYWdlQ2xhc3NpZmljYXRpb25cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@huggingface/inference/dist/index.js\n");

/***/ })

};
;